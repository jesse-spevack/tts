# Hub MVP Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build Hub Rails application with magic link authentication, Stripe billing, episode management (web + API), API key generation, marketing landing page, and Cloud Tasks integration with Generator service.

**Architecture:** Rails 8 application using SQLite database, magic link authentication, Stripe for subscriptions, GCS for file staging, and Cloud Tasks for async job processing. Implements both web UI and REST API endpoints with shared business logic.

**Tech Stack:** Ruby on Rails 8.0+, SQLite3, Rails authentication (magic link), Stripe Ruby SDK, Google Cloud Storage SDK, Google Cloud Tasks SDK, Tailwind CSS, Hotwire (Turbo + Stimulus)

---

## Prerequisites

Before starting, ensure you have:
- Ruby 3.4+
- Rails 8.0+
- SQLite3
- Google Cloud CLI (`gcloud`)
- Active GCP project
- Stripe account
- SMTP server for sending magic link emails (or use letter_opener in dev)

---

## Task 1: Scaffold Rails Application

**Files:**
- Create: `hub/` directory and Rails app structure

**Step 1: Create hub directory and scaffold Rails app**

From monorepo root:
```bash
rails new hub --database=sqlite3 --css=tailwind
cd hub
```

**Step 2: Add essential gems**

Edit `hub/Gemfile`, add after existing gems:
```ruby
group :development, :test do
  gem "debug", platforms: %i[mri windows]
  gem "dotenv-rails"
end

group :development do
  gem "letter_opener" # Preview emails in browser
end
```

Note: Additional gems (Stripe, Google Cloud SDKs, bcrypt) will be added in later tasks when those features are implemented.

**Step 3: Install dependencies**

Run:
```bash
bundle install
```

Expected: All gems installed successfully

**Step 4: Initialize Kamal for deployment**

Run:
```bash
kamal init
```

Expected: Creates `config/deploy.yml` and `.kamal/secrets` files

**Step 5: Configure Kamal secrets**

Edit `.kamal/secrets` to define secret loading (this file is gitignored by default):
```bash
# .kamal/secrets - Loaded by Kamal for deployments
# Secrets will be added as features are implemented

# Example format (will populate in later tasks):
# STRIPE_API_KEY=$(kamal secrets fetch STRIPE_API_KEY)
# GENERATOR_CALLBACK_SECRET=$(kamal secrets fetch GENERATOR_CALLBACK_SECRET)
```

Note: Actual secrets will be stored in password manager or CI/CD secrets and fetched via `kamal secrets fetch`

**Step 6: Update .gitignore**

Verify `hub/.gitignore` includes (should be there by default):
```
.kamal/secrets
.kamal/secrets-*
config/master.key
```

**Step 7: Configure letter_opener for development**

Edit `hub/config/environments/development.rb`, add inside `Rails.application.configure do`:
```ruby
  # Preview emails in browser instead of sending
  config.action_mailer.delivery_method = :letter_opener
  config.action_mailer.perform_deliveries = true
  config.action_mailer.default_url_options = { host: 'localhost', port: 3000 }
```

**Step 8: Initial commit**

From monorepo root:
```bash
git add hub/
git commit -m "feat(hub): scaffold Rails application with dependencies"
```

---

## Task 2: Research and Choose Email Service

**Files:**
- Create: `docs/decisions/email-service-choice.md`

**Step 1: Research Resend**

Visit https://resend.com/docs and review:
- Pricing (free tier, paid tiers)
- Ruby SDK availability
- API simplicity
- Deliverability features
- Developer experience

Document findings in `docs/decisions/email-service-choice.md`

**Step 2: Research Loops**

Visit https://loops.so/docs and review:
- Pricing (free tier, paid tiers)
- Ruby SDK or API availability
- Transactional email support
- Developer experience
- Marketing features (if relevant)

Add findings to the decision document

**Step 3: Make decision**

Compare both services based on:
- Cost for expected volume
- Ease of integration
- API quality
- Deliverability reputation

Document final choice in `docs/decisions/email-service-choice.md` with rationale

**Step 4: Add chosen gem to Gemfile**

Based on decision, add to `hub/Gemfile`:
```ruby
# For Resend:
gem "resend", "~> 0.8.0"

# OR for Loops:
gem "loops_sdk", "~> 0.2.0"  # (check for actual gem name)
```

**Step 5: Install gem**

Run:
```bash
bundle install
```

Expected: Email service gem installed

**Step 6: Commit decision**

From monorepo root:
```bash
git add hub/Gemfile hub/Gemfile.lock docs/decisions/
git commit -m "feat(hub): add email service gem (resend/loops)"
```

---

## Task 3: Generate Authentication with Magic Links

**Files:**
- Creates: User model, SessionsController, PasswordsMailer, views, routes

**Step 1: Generate Rails 8 authentication**

Run:
```bash
cd hub
rails generate authentication
```

Expected: Creates User model, sessions controller, mailer, and views

**Step 2: Review generated files**

Check that these were created:
- `app/models/user.rb`
- `app/controllers/sessions_controller.rb`
- `app/controllers/passwords_controller.rb`
- `app/mailers/passwords_mailer.rb`
- Views in `app/views/sessions/` and `app/views/passwords/`

**Step 3: Run migrations**

Run:
```bash
rails db:migrate
```

Expected: User table created with email and password_digest columns

**Step 4: Update User model for our needs**

Edit `app/models/user.rb`, add after existing code:
```ruby
  has_many :podcasts, dependent: :destroy
  has_many :api_keys, dependent: :destroy

  validates :email, presence: true, uniqueness: true, format: { with: URI::MailTo::EMAIL_REGEXP }

  # Subscription status tracking
  attribute :stripe_customer_id, :string
  attribute :stripe_subscription_id, :string
  attribute :subscription_status, :string, default: 'inactive'

  def active_subscription?
    subscription_status == 'active'
  end

  def subscribed?
    %w[active past_due].include?(subscription_status)
  end
```

**Step 5: Create migration for subscription fields**

Run:
```bash
rails generate migration AddSubscriptionFieldsToUsers stripe_customer_id:string stripe_subscription_id:string subscription_status:string
```

**Step 6: Edit the migration**

Edit `db/migrate/*_add_subscription_fields_to_users.rb`:
```ruby
class AddSubscriptionFieldsToUsers < ActiveRecord::Migration[8.0]
  def change
    add_column :users, :stripe_customer_id, :string
    add_column :users, :stripe_subscription_id, :string
    add_column :users, :subscription_status, :string, default: 'inactive', null: false

    add_index :users, :stripe_customer_id
  end
end
```

**Step 7: Run migration**

Run:
```bash
rails db:migrate
```

Expected: Subscription columns added to users table

**Step 8: Write tests for User model extensions**

Create `test/models/user_test.rb`:
```ruby
require "test_helper"

class UserTest < ActiveSupport::TestCase
  test "creates user with email" do
    user = User.create!(email: "test@example.com")
    assert user.persisted?
    assert_equal "test@example.com", user.email
  end

  test "validates email uniqueness" do
    User.create!(email: "test@example.com")
    duplicate = User.new(email: "test@example.com")
    assert_not duplicate.valid?
    assert_includes duplicate.errors[:email], "has already been taken"
  end

  test "active_subscription? returns true when status is active" do
    user = User.new(subscription_status: 'active')
    assert user.active_subscription?
  end

  test "active_subscription? returns false when status is inactive" do
    user = User.new(subscription_status: 'inactive')
    assert_not user.active_subscription?
  end

  test "subscribed? returns true for active status" do
    user = User.new(subscription_status: 'active')
    assert user.subscribed?
  end

  test "subscribed? returns true for past_due status" do
    user = User.new(subscription_status: 'past_due')
    assert user.subscribed?
  end

  test "subscribed? returns false for inactive status" do
    user = User.new(subscription_status: 'inactive')
    assert_not user.subscribed?
  end

  test "has association with podcast" do
    user = User.create!(email: "test@example.com")
    assert_respond_to user, :podcast
  end

  test "has association with api_keys" do
    user = User.create!(email: "test@example.com")
    assert_respond_to user, :api_keys
  end
end
```

**Step 9: Run tests**

Run:
```bash
rails test test/models/user_test.rb
```

Expected: All tests pass

**Step 10: Test authentication flow manually**

Run:
```bash
rails server
```

Visit `http://localhost:3000` and test:
1. Sign up with email
2. Check letter_opener (opens in browser) for magic link
3. Click magic link to authenticate
4. Verify session works

Expected: Magic link authentication working

**Step 11: Commit authentication**

From monorepo root:
```bash
git add hub/
git commit -m "feat(hub): add Rails 8 magic link authentication"
```

---

## Task 4: Create Additional Models (Podcast, PodcastMembership, Episode, ApiKey)

**Files:**
- Create: `app/models/podcast.rb`
- Create: `app/models/podcast_membership.rb`
- Create: `app/models/episode.rb`
- Create: `app/models/api_key.rb`
- Create: Database migrations

**Step 1: Generate Podcast model**

Run:
```bash
cd hub
rails generate model Podcast podcast_id:string title:string description:text author:string
```

**Step 2: Update Podcast migration**

Edit `db/migrate/*_create_podcasts.rb`:
```ruby
class CreatePodcasts < ActiveRecord::Migration[8.0]
  def change
    create_table :podcasts do |t|
      t.string :podcast_id, null: false
      t.string :title
      t.text :description
      t.string :author

      t.timestamps
    end

    add_index :podcasts, :podcast_id, unique: true
  end
end
```

**Step 3: Generate PodcastMembership join model**

Run:
```bash
rails generate model PodcastMembership user:references podcast:references role:string
```

**Step 4: Update PodcastMembership migration**

Edit `db/migrate/*_create_podcast_memberships.rb`:
```ruby
class CreatePodcastMemberships < ActiveRecord::Migration[8.0]
  def change
    create_table :podcast_memberships do |t|
      t.references :user, null: false, foreign_key: true
      t.references :podcast, null: false, foreign_key: true
      t.string :role, null: false, default: 'owner'

      t.timestamps
    end

    add_index :podcast_memberships, [:user_id, :podcast_id], unique: true
  end
end
```

**Step 5: Update User model associations**

Edit `app/models/user.rb`, replace the podcasts association:
```ruby
  has_many :podcast_memberships, dependent: :destroy
  has_many :podcasts, through: :podcast_memberships
  has_many :api_keys, dependent: :destroy
```

**Step 6: Update Podcast model**

Edit `app/models/podcast.rb`:
```ruby
class Podcast < ApplicationRecord
  has_many :podcast_memberships, dependent: :destroy
  has_many :users, through: :podcast_memberships
  has_many :episodes, dependent: :destroy

  validates :podcast_id, presence: true, uniqueness: true

  before_validation :generate_podcast_id, on: :create

  def feed_url
    return nil unless podcast_id.present?

    bucket = ENV.fetch('GOOGLE_CLOUD_BUCKET')
    "https://storage.googleapis.com/#{bucket}/podcasts/#{podcast_id}/feed.xml"
  end

  private

  def generate_podcast_id
    self.podcast_id ||= "podcast_#{SecureRandom.hex(8)}"
  end
end
```

**Step 7: Create PodcastMembership model**

Edit `app/models/podcast_membership.rb`:
```ruby
class PodcastMembership < ApplicationRecord
  belongs_to :user
  belongs_to :podcast

  validates :user_id, uniqueness: { scope: :podcast_id }
  validates :role, inclusion: { in: %w[owner editor viewer] }

  scope :owners, -> { where(role: 'owner') }
  scope :editors, -> { where(role: 'editor') }

  def owner?
    role == 'owner'
  end

  def editor?
    role == 'editor'
  end

  def viewer?
    role == 'viewer'
  end
end
```

**Step 4: Generate Episode model**

Run:
```bash
rails generate model Episode podcast:references title:string author:string description:text status:string gcs_episode_id:string error_message:text audio_size_bytes:integer duration_seconds:integer
```

**Step 5: Update Episode migration**

Edit `db/migrate/*_create_episodes.rb`:
```ruby
class CreateEpisodes < ActiveRecord::Migration[8.0]
  def change
    create_table :episodes do |t|
      t.references :podcast, null: false, foreign_key: true
      t.string :title, null: false
      t.string :author, null: false
      t.text :description, null: false
      t.string :status, null: false, default: 'pending'
      t.string :gcs_episode_id
      t.text :error_message
      t.integer :audio_size_bytes
      t.integer :duration_seconds

      t.timestamps
    end

    add_index :episodes, :status
    add_index :episodes, :gcs_episode_id
  end
end
```

**Step 6: Update Episode model**

Edit `app/models/episode.rb`:
```ruby
class Episode < ApplicationRecord
  belongs_to :podcast

  validates :title, presence: true, length: { maximum: 255 }
  validates :author, presence: true, length: { maximum: 255 }
  validates :description, presence: true, length: { maximum: 1000 }
  validates :status, inclusion: { in: %w[pending processing complete failed] }

  scope :pending, -> { where(status: 'pending') }
  scope :processing, -> { where(status: 'processing') }
  scope :complete, -> { where(status: 'complete') }
  scope :failed, -> { where(status: 'failed') }
  scope :recent, -> { order(created_at: :desc) }

  def pending?
    status == 'pending'
  end

  def processing?
    status == 'processing'
  end

  def complete?
    status == 'complete'
  end

  def failed?
    status == 'failed'
  end

  def audio_url
    return nil unless complete? && gcs_episode_id.present?

    bucket = ENV.fetch('GOOGLE_CLOUD_BUCKET')
    podcast_id = podcast.podcast_id
    "https://storage.googleapis.com/#{bucket}/podcasts/#{podcast_id}/episodes/#{gcs_episode_id}.mp3"
  end
end
```

**Step 7: Generate ApiKey model**

Run:
```bash
rails generate model ApiKey user:references key_hash:string key_prefix:string name:string last_used_at:datetime revoked_at:datetime
```

**Step 8: Update ApiKey migration**

Edit `db/migrate/*_create_api_keys.rb`:
```ruby
class CreateApiKeys < ActiveRecord::Migration[8.0]
  def change
    create_table :api_keys do |t|
      t.references :user, null: false, foreign_key: true
      t.string :key_hash, null: false
      t.string :key_prefix, null: false
      t.string :name
      t.datetime :last_used_at
      t.datetime :revoked_at

      t.timestamps
    end

    add_index :api_keys, :key_hash, unique: true
    add_index :api_keys, :key_prefix
  end
end
```

**Step 9: Update ApiKey model**

Edit `app/models/api_key.rb`:
```ruby
class ApiKey < ApplicationRecord
  belongs_to :user

  validates :key_hash, presence: true, uniqueness: true
  validates :key_prefix, presence: true

  scope :active, -> { where(revoked_at: nil) }

  # Generate a new API key
  # @return [Array<ApiKey, String>] The saved ApiKey record and the plaintext key
  def self.generate(user:, name: nil)
    plaintext_key = "pk_live_#{SecureRandom.hex(16)}"
    key_hash = BCrypt::Password.create(plaintext_key)
    key_prefix = plaintext_key[0..11] # "pk_live_xxxx"

    api_key = create!(
      user: user,
      key_hash: key_hash,
      key_prefix: key_prefix,
      name: name
    )

    [api_key, plaintext_key]
  end

  # Authenticate an API key
  # @param plaintext_key [String] The key to verify
  # @return [ApiKey, nil] The matching ApiKey or nil
  def self.authenticate(plaintext_key)
    return nil if plaintext_key.blank?

    # Find all active keys and check each one
    active.find do |api_key|
      BCrypt::Password.new(api_key.key_hash) == plaintext_key
    rescue BCrypt::Errors::InvalidHash
      false
    end
  end

  def revoke!
    update!(revoked_at: Time.current)
  end

  def active?
    revoked_at.nil?
  end

  def rate_limited?
    return false if last_used_at.nil?

    last_used_at > 1.minute.ago
  end

  def record_usage!
    update!(last_used_at: Time.current)
  end
end
```

**Step 10: Run migrations**

Run:
```bash
rails db:migrate
```

Expected: All tables created successfully

**Step 11: Write model tests**

Create `test/models/podcast_test.rb`:
```ruby
require "test_helper"

class PodcastTest < ActiveSupport::TestCase
  def setup
    @user = User.create!(email: "test@example.com")
  end

  test "generates podcast_id on creation" do
    podcast = Podcast.create!(user: @user)
    assert_match /^podcast_[a-f0-9]{16}$/, podcast.podcast_id
  end

  test "validates uniqueness of podcast_id" do
    podcast1 = Podcast.create!(user: @user, podcast_id: "podcast_abc123")
    podcast2 = Podcast.new(user: @user, podcast_id: "podcast_abc123")

    assert_not podcast2.valid?
    assert_includes podcast2.errors[:podcast_id], "has already been taken"
  end

  test "feed_url returns correct GCS URL" do
    podcast = Podcast.create!(user: @user, podcast_id: "podcast_test123")

    ENV['GOOGLE_CLOUD_BUCKET'] = 'test-bucket'
    expected_url = "https://storage.googleapis.com/test-bucket/podcasts/podcast_test123/feed.xml"

    assert_equal expected_url, podcast.feed_url
  end

  test "belongs to user" do
    podcast = Podcast.create!(user: @user)
    assert_equal @user, podcast.user
  end

  test "has many episodes" do
    podcast = Podcast.create!(user: @user)
    assert_respond_to podcast, :episodes
  end
end
```

Create `test/models/episode_test.rb`:
```ruby
require "test_helper"

class EpisodeTest < ActiveSupport::TestCase
  def setup
    @user = User.create!(email: "test@example.com")
    @podcast = Podcast.create!(user: @user)
  end

  test "creates episode with required attributes" do
    episode = Episode.create!(
      podcast: @podcast,
      title: "Test Episode",
      author: "John Doe",
      description: "A test episode"
    )

    assert episode.persisted?
    assert_equal "pending", episode.status
  end

  test "validates presence of title" do
    episode = Episode.new(podcast: @podcast, author: "John", description: "Desc")
    assert_not episode.valid?
    assert_includes episode.errors[:title], "can't be blank"
  end

  test "validates status inclusion" do
    episode = Episode.new(
      podcast: @podcast,
      title: "Test",
      author: "John",
      description: "Desc",
      status: "invalid_status"
    )

    assert_not episode.valid?
    assert_includes episode.errors[:status], "is not included in the list"
  end

  test "status scopes filter correctly" do
    pending = Episode.create!(podcast: @podcast, title: "P", author: "A", description: "D", status: "pending")
    processing = Episode.create!(podcast: @podcast, title: "Pr", author: "A", description: "D", status: "processing")
    complete = Episode.create!(podcast: @podcast, title: "C", author: "A", description: "D", status: "complete")

    assert_includes Episode.pending, pending
    assert_includes Episode.processing, processing
    assert_includes Episode.complete, complete
  end

  test "audio_url returns correct URL for complete episode" do
    ENV['GOOGLE_CLOUD_BUCKET'] = 'test-bucket'

    episode = Episode.create!(
      podcast: @podcast,
      title: "Test",
      author: "A",
      description: "D",
      status: "complete",
      gcs_episode_id: "episode_xyz"
    )

    expected_url = "https://storage.googleapis.com/test-bucket/podcasts/#{@podcast.podcast_id}/episodes/episode_xyz.mp3"
    assert_equal expected_url, episode.audio_url
  end

  test "audio_url returns nil for non-complete episode" do
    episode = Episode.create!(
      podcast: @podcast,
      title: "Test",
      author: "A",
      description: "D",
      status: "pending"
    )

    assert_nil episode.audio_url
  end
end
```

Create `test/models/api_key_test.rb`:
```ruby
require "test_helper"

class ApiKeyTest < ActiveSupport::TestCase
  def setup
    @user = User.create!(email: "test@example.com")
  end

  test "generates API key with correct format" do
    api_key, plaintext = ApiKey.generate(user: @user, name: "Test Key")

    assert api_key.persisted?
    assert_match /^pk_live_[a-f0-9]{32}$/, plaintext
    assert_equal plaintext[0..11], api_key.key_prefix
    assert_equal "Test Key", api_key.name
  end

  test "authenticate returns api_key for valid plaintext" do
    api_key, plaintext = ApiKey.generate(user: @user)

    authenticated = ApiKey.authenticate(plaintext)
    assert_equal api_key, authenticated
  end

  test "authenticate returns nil for invalid plaintext" do
    ApiKey.generate(user: @user)

    authenticated = ApiKey.authenticate("invalid_key")
    assert_nil authenticated
  end

  test "authenticate returns nil for revoked key" do
    api_key, plaintext = ApiKey.generate(user: @user)
    api_key.revoke!

    authenticated = ApiKey.authenticate(plaintext)
    assert_nil authenticated
  end

  test "rate_limited? returns true when used within 1 minute" do
    api_key, _ = ApiKey.generate(user: @user)
    api_key.update!(last_used_at: 30.seconds.ago)

    assert api_key.rate_limited?
  end

  test "rate_limited? returns false when used over 1 minute ago" do
    api_key, _ = ApiKey.generate(user: @user)
    api_key.update!(last_used_at: 2.minutes.ago)

    assert_not api_key.rate_limited?
  end

  test "record_usage! updates last_used_at" do
    api_key, _ = ApiKey.generate(user: @user)

    assert_nil api_key.last_used_at

    api_key.record_usage!
    assert_not_nil api_key.last_used_at
    assert_in_delta Time.current, api_key.last_used_at, 1.second
  end
end
```

**Step 12: Run all model tests**

Run:
```bash
rails test test/models/
```

Expected: All tests pass

**Step 13: Commit models**

From monorepo root:
```bash
git add hub/
git commit -m "feat(hub): add Podcast, Episode, ApiKey models with tests"
```

---

## Task 4: Marketing Landing Page

**Files:**
- Create: `app/controllers/home_controller.rb`
- Create: `app/views/home/index.html.erb`
- Modify: `config/routes.rb`

**Step 1: Generate Home controller**

Run:
```bash
rails generate controller Home index
```

Expected: Creates controller, view, and adds route

**Step 2: Update home view with landing page**

Edit `app/views/home/index.html.erb`:
```erb
<div class="min-h-screen bg-gradient-to-b from-blue-50 to-white">
  <!-- Hero Section -->
  <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 pt-20 pb-16">
    <div class="text-center">
      <h1 class="text-5xl font-bold text-gray-900 mb-6">
        Turn Your Articles into Podcasts
      </h1>
      <p class="text-xl text-gray-600 mb-8 max-w-2xl mx-auto">
        Upload markdown articles and get professional text-to-speech podcast episodes with automatic RSS feed generation.
      </p>

      <%= link_to "Get Started", new_session_path, class: "inline-block bg-blue-600 text-white px-8 py-3 rounded-lg font-semibold hover:bg-blue-700 transition" %>
    </div>
  </div>

  <!-- Features Section -->
  <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-16">
    <div class="grid md:grid-cols-3 gap-8">
      <div class="text-center p-6">
        <div class="text-4xl mb-4">üéôÔ∏è</div>
        <h3 class="text-xl font-semibold mb-2">Professional TTS</h3>
        <p class="text-gray-600">High-quality AI voices powered by Google Cloud Text-to-Speech</p>
      </div>

      <div class="text-center p-6">
        <div class="text-4xl mb-4">üì±</div>
        <h3 class="text-xl font-semibold mb-2">Instant RSS Feed</h3>
        <p class="text-gray-600">Automatic RSS feed generation for all major podcast apps</p>
      </div>

      <div class="text-center p-6">
        <div class="text-4xl mb-4">‚ö°</div>
        <h3 class="text-xl font-semibold mb-2">Web or API</h3>
        <p class="text-gray-600">Use our web interface or integrate via API for automation</p>
      </div>
    </div>
  </div>

  <!-- Pricing Section -->
  <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-16">
    <div class="text-center mb-12">
      <h2 class="text-3xl font-bold text-gray-900 mb-4">Simple Pricing</h2>
      <p class="text-gray-600">Start creating podcast episodes today</p>
    </div>

    <div class="max-w-md mx-auto bg-white rounded-lg shadow-lg p-8">
      <div class="text-center">
        <h3 class="text-2xl font-bold mb-4">Pro Plan</h3>
        <div class="mb-6">
          <span class="text-4xl font-bold">$29</span>
          <span class="text-gray-600">/month</span>
        </div>
        <ul class="text-left space-y-3 mb-8">
          <li class="flex items-center">
            <svg class="w-5 h-5 text-green-500 mr-2" fill="currentColor" viewBox="0 0 20 20">
              <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"/>
            </svg>
            Unlimited episodes
          </li>
          <li class="flex items-center">
            <svg class="w-5 h-5 text-green-500 mr-2" fill="currentColor" viewBox="0 0 20 20">
              <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"/>
            </svg>
            RSS feed hosting
          </li>
          <li class="flex items-center">
            <svg class="w-5 h-5 text-green-500 mr-2" fill="currentColor" viewBox="0 0 20 20">
              <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"/>
            </svg>
            API access
          </li>
          <li class="flex items-center">
            <svg class="w-5 h-5 text-green-500 mr-2" fill="currentColor" viewBox="0 0 20 20">
              <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"/>
            </svg>
            Premium TTS voices
          </li>
        </ul>
        <%= link_to "Start Free Trial", new_session_path, class: "block w-full bg-blue-600 text-white px-6 py-3 rounded-lg font-semibold hover:bg-blue-700 transition text-center" %>
      </div>
    </div>
  </div>
</div>
```

**Step 3: Set root route**

Edit `config/routes.rb`:
```ruby
Rails.application.routes.draw do
  root "home#index"

  # Health check
  get "up" => "rails/health#show", as: :rails_health_check

  # Existing session routes from authentication generator
  # (will be there already)
end
```

**Step 4: Test landing page**

Run:
```bash
rails server
```

Visit `http://localhost:3000`

Expected: See marketing landing page with hero, features, and pricing

**Step 5: Write controller test**

Create `test/controllers/home_controller_test.rb`:
```ruby
require "test_helper"

class HomeControllerTest < ActionDispatch::IntegrationTest
  test "should get index" do
    get root_url
    assert_response :success
    assert_select "h1", "Turn Your Articles into Podcasts"
  end
end
```

**Step 6: Run controller test**

Run:
```bash
rails test test/controllers/home_controller_test.rb
```

Expected: Test passes

**Step 7: Commit landing page**

From monorepo root:
```bash
git add hub/
git commit -m "feat(hub): add marketing landing page"
```

---

## Remaining Tasks (To Be Detailed)

The plan continues with these tasks, each following the same TDD pattern:

- **Task 5:** Stripe Integration Service
- **Task 6:** GCS Upload Service
- **Task 7:** Cloud Tasks Enqueuer Service
- **Task 8:** Authentication Concerns for Controllers
- **Task 9:** Episodes Controller (Web UI)
- **Task 10:** API v1 Episodes Controller
- **Task 11:** API v1 Podcasts Controller
- **Task 12:** API v1 API Keys Controller
- **Task 13:** Internal API Controller (Generator callbacks)
- **Task 14:** Episode Views and Forms
- **Task 15:** Developer Dashboard for API Keys
- **Task 16:** Deployment Configuration
- **Task 17:** Update Generator Service
  - Remove podcast_id generation logic from Generator
  - Generator should validate podcast_id is always provided in requests
  - Hub is now the source of truth for podcast_id
- **Task 18:** End-to-End Integration Tests

Each task will include:
- Failing tests first
- Minimal implementation
- Verification steps
- Commit after each task

---

## Execution Handoff

Plan saved to `docs/plans/2025-11-03-hub-mvp.md`.

**Two execution options:**

**1. Subagent-Driven (this session)** - I dispatch fresh subagent per task, review between tasks

**2. Parallel Session (separate)** - Open new session with executing-plans for batch execution

**Which approach?**

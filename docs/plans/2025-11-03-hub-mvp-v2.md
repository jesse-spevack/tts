# Hub MVP Implementation Plan (v2 - End-to-End Focus)

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build a working end-to-end flow where users can sign up, automatically get a podcast created, upload markdown episodes, and see them process to audio with an RSS feed URL.

**MVP Scope:**
1. User signs up with magic link authentication
2. System auto-creates one podcast for user on signup
3. User uploads markdown episode (web form)
4. Episode processes via Generator (Cloud Tasks)
5. User sees episode list with processing status
6. User sees RSS feed URL for their podcast

**Deferred to Later:**
- Stripe billing (free tier initially)
- API keys / programmatic access
- Marketing landing page
- Creating additional podcasts
- Podcast collaboration features
- Podcast settings/customization

**Architecture:** Rails 8 with SQLite, magic link auth, many-to-many User/Podcast schema (simple UI), Generator integration via Cloud Tasks, GCS for storage.

**Tech Stack:** Ruby on Rails 8.0+, SQLite3, Rails authentication (magic link), Email service (Resend/Loops), Google Cloud Storage SDK, Google Cloud Tasks SDK, Tailwind CSS

---

## Task 1: Scaffold Rails Application ‚úÖ

**Goal:** Create basic Rails app with essential gems

**Step 1: Create Rails app** ‚úÖ

From monorepo root:
```bash
rails new hub --database=sqlite3 --css=tailwind
cd hub
```

**Step 2: Add essential gems** ‚úÖ

Edit `hub/Gemfile`, add:
```ruby
group :development, :test do
  gem "debug", platforms: %i[mri windows]
end

group :development do
  gem "letter_opener" # Preview emails in browser
end
```

Note: Using Kamal secrets for environment variables instead of dotenv-rails

**Step 3: Install dependencies** ‚úÖ

Run:
```bash
bundle install
```

**Step 4: Initialize Kamal** ‚úÖ

Run:
```bash
kamal init
```

Expected: Creates `config/deploy.yml` and `.kamal/secrets`

**Step 5: Configure letter_opener** ‚úÖ

Edit `hub/config/environments/development.rb`, add inside `Rails.application.configure do`:
```ruby
  # Preview emails in browser instead of sending
  config.action_mailer.delivery_method = :letter_opener
  config.action_mailer.perform_deliveries = true
  config.action_mailer.default_url_options = { host: 'localhost', port: 3000 }
```

**Step 6: Commit** ‚úÖ

From monorepo root:
```bash
git add hub/
git commit -m "feat(hub): scaffold Rails application"
```

**Status:** COMPLETED - Basic Rails 8 app scaffolded with Tailwind CSS, Kamal, and letter_opener gem installed.

---

## Task 2: Choose and Add Email Service ‚úÖ

**Goal:** Research and integrate email service for magic links

**Step 1: Research Resend**

Quick research:
- Pricing: 3,000 emails/month free, $20/month for 50k
- Ruby gem: `resend` gem available
- API: Simple REST API
- Deliverability: Excellent reputation

**Step 2: Research Loops**

Quick research:
- Pricing: Free tier available, focused on marketing
- Ruby: REST API available, no official gem
- Transactional: Supports transactional emails
- Focus: More marketing-oriented

**Step 3: Decision - Choose Resend**

Rationale:
- Better for transactional emails
- Official Ruby gem
- Simpler API
- Better developer experience

**Step 4: Add Resend gem**

Edit `hub/Gemfile`:
```ruby
gem "resend", "~> 0.8.0"
```

**Step 5: Install**

Run:
```bash
bundle install
```

**Step 6: Configure Resend**

Create `hub/config/initializers/resend.rb`:
```ruby
require 'resend'

Resend.api_key = ENV.fetch('RESEND_API_KEY', 'dummy_key_for_development')
```

**Step 7: Configure Kamal secrets with 1Password**

Edit `.kamal/secrets` to use 1Password adapter:
```bash
# Using 1Password CLI adapter
RESEND_API_KEY=$(op read "op://vault/item/field")
```

Note: Configure 1Password vault and item references for your secrets

**Step 8: Commit** ‚úÖ

```bash
git add hub/
git commit -m "feat(hub): add Resend for email delivery"
```

**Status:** COMPLETED - Resend gem installed and configured. Note: Kamal secrets need 1Password CLI integration setup, currently using direct environment variable in development.local.rb

---

## Task 3: Set Up Authentication with Magic Links ‚úÖ

**Goal:** Working magic link authentication

**Status:** COMPLETED

**Implementation:** Custom passwordless magic link authentication (not using Rails generator)

**What was built:**

1. **Database Schema:**
   - `users` table: `email_address`, `auth_token`, `auth_token_expires_at`
   - `sessions` table: `user_id`, `ip_address`, `user_agent`
   - Migrations created and run ‚úÖ

2. **Service Layer (4 services):**
   - `GenerateAuthToken.call(user:)` - Creates secure token with 30min expiration
   - `ValidateAuthToken.call(user:)` - Validates token is present and not expired
   - `SendMagicLink.call(email_address:)` - Finds/creates user, generates token, sends email
   - `AuthenticateMagicLink.call(token:)` - Validates token, invalidates after use, returns user

3. **Models:**
   - `User` - Pure data model with email validation and normalization
   - `Session` - Tracks user sessions with IP and user agent
   - `Current` - Thread-safe current session storage

4. **Controllers:**
   - `SessionsController` - RESTful actions only (new, create, destroy)
   - `Authentication` concern - App-wide authentication requirement

5. **Mailer:**
   - `SessionsMailer` - Sends magic link emails using Resend
   - Subject: "üéôÔ∏è Your TTS Login Link"
   - HTML-only template (no plain text)

6. **Authentication Flow (RESTful):**
   - User enters email ‚Üí POST `/session` ‚Üí sends magic link email
   - User clicks link ‚Üí GET `/session/new?token=xxx` ‚Üí authenticates ‚Üí redirects
   - DELETE `/session` ‚Üí logs out

**Testing:**
- 33 tests, 72 assertions, all passing ‚úÖ
- RuboCop clean ‚úÖ
- Comprehensive service tests (5 + 7 + 8 + 6 tests)

**Key Decisions:**
- ‚úÖ Removed password-based authentication (no bcrypt needed)
- ‚úÖ Service objects for all business logic (not in models/controllers)
- ‚úÖ One-time use tokens (invalidated after successful auth)
- ‚úÖ RESTful routes only (no custom authenticate action)
- ‚úÖ Follows gournal app authentication pattern

**Commits:**
- Initial magic link implementation
- Extract service objects (AuthenticateMagicLink, SendMagicLink)
- Extract auth token services (GenerateAuthToken, ValidateAuthToken)
- Remove unused Action Cable
- Remove bcrypt gem
- RuboCop fixes

---

## Task 4: Create Database Models ‚è∏Ô∏è

**Goal:** Set up User, Podcast, PodcastMembership, Episode models with many-to-many support

**Status:** NOT STARTED - Depends on Task 3

**Step 1: Add subscription fields to User**

Run:
```bash
rails generate migration AddSubscriptionFieldsToUsers stripe_customer_id:string stripe_subscription_id:string subscription_status:string
```

Edit migration:
```ruby
class AddSubscriptionFieldsToUsers < ActiveRecord::Migration[8.0]
  def change
    add_column :users, :stripe_customer_id, :string
    add_column :users, :stripe_subscription_id, :string
    add_column :users, :subscription_status, :string, default: 'active', null: false

    add_index :users, :stripe_customer_id
  end
end
```

Note: Default to 'active' since we're not doing billing yet

**Step 2: Generate Podcast model**

Run:
```bash
rails generate model Podcast podcast_id:string title:string description:text
```

Edit migration:
```ruby
class CreatePodcasts < ActiveRecord::Migration[8.0]
  def change
    create_table :podcasts do |t|
      t.string :podcast_id, null: false
      t.string :title
      t.text :description

      t.timestamps
    end

    add_index :podcasts, :podcast_id, unique: true
  end
end
```

**Step 3: Generate PodcastMembership**

Run:
```bash
rails generate model PodcastMembership user:references podcast:references role:string
```

Edit migration:
```ruby
class CreatePodcastMemberships < ActiveRecord::Migration[8.0]
  def change
    create_table :podcast_memberships do |t|
      t.references :user, null: false, foreign_key: true
      t.references :podcast, null: false, foreign_key: true
      t.string :role, null: false, default: 'owner'

      t.timestamps
    end

    add_index :podcast_memberships, [:user_id, :podcast_id], unique: true
  end
end
```

**Step 4: Generate Episode model**

Run:
```bash
rails generate model Episode podcast:references title:string author:string description:text status:string gcs_episode_id:string error_message:text audio_size_bytes:integer duration_seconds:integer
```

Edit migration:
```ruby
class CreateEpisodes < ActiveRecord::Migration[8.0]
  def change
    create_table :episodes do |t|
      t.references :podcast, null: false, foreign_key: true
      t.string :title, null: false
      t.string :author, null: false
      t.text :description, null: false
      t.string :status, null: false, default: 'pending'
      t.string :gcs_episode_id
      t.text :error_message
      t.integer :audio_size_bytes
      t.integer :duration_seconds

      t.timestamps
    end

    add_index :episodes, :status
    add_index :episodes, :gcs_episode_id
  end
end
```

**Step 5: Run migrations**

Run:
```bash
rails db:migrate
```

**Step 6: Update User model**

Edit `app/models/user.rb`:
```ruby
class User < ApplicationRecord
  has_secure_password
  has_many :podcast_memberships, dependent: :destroy
  has_many :podcasts, through: :podcast_memberships

  validates :email, presence: true, uniqueness: true, format: { with: URI::MailTo::EMAIL_REGEXP }

  def active_subscription?
    subscription_status == 'active'
  end
end
```

**Step 7: Create Podcast model**

Edit `app/models/podcast.rb`:
```ruby
class Podcast < ApplicationRecord
  has_many :podcast_memberships, dependent: :destroy
  has_many :users, through: :podcast_memberships
  has_many :episodes, dependent: :destroy

  validates :podcast_id, presence: true, uniqueness: true

  before_validation :generate_podcast_id, on: :create

  def feed_url
    return nil unless podcast_id.present?

    bucket = ENV.fetch('GOOGLE_CLOUD_BUCKET', 'podcast-bucket')
    "https://storage.googleapis.com/#{bucket}/podcasts/#{podcast_id}/feed.xml"
  end

  private

  def generate_podcast_id
    self.podcast_id ||= "podcast_#{SecureRandom.hex(8)}"
  end
end
```

**Step 8: Create PodcastMembership model**

Edit `app/models/podcast_membership.rb`:
```ruby
class PodcastMembership < ApplicationRecord
  belongs_to :user
  belongs_to :podcast

  validates :user_id, uniqueness: { scope: :podcast_id }
  validates :role, inclusion: { in: %w[owner editor viewer] }
end
```

Note: Role predicate methods (owner?, editor?) will be added later when we build collaboration features

**Step 9: Create Episode model**

Edit `app/models/episode.rb`:
```ruby
class Episode < ApplicationRecord
  belongs_to :podcast

  validates :title, presence: true, length: { maximum: 255 }
  validates :author, presence: true, length: { maximum: 255 }
  validates :description, presence: true, length: { maximum: 1000 }
  validates :status, inclusion: { in: %w[pending processing complete failed] }

  scope :recent, -> { order(created_at: :desc) }

  def pending?
    status == 'pending'
  end

  def processing?
    status == 'processing'
  end

  def complete?
    status == 'complete'
  end

  def failed?
    status == 'failed'
  end

  def audio_url
    return nil unless complete? && gcs_episode_id.present?

    bucket = ENV.fetch('GOOGLE_CLOUD_BUCKET', 'podcast-bucket')
    podcast_id = podcast.podcast_id
    "https://storage.googleapis.com/#{bucket}/podcasts/#{podcast_id}/episodes/#{gcs_episode_id}.mp3"
  end
end
```

**Step 10: Write basic model tests**

Create `test/models/user_test.rb`:
```ruby
require "test_helper"

class UserTest < ActiveSupport::TestCase
  test "user has many podcasts through memberships" do
    user = User.create!(email: "test@example.com", password: "password")
    assert_respond_to user, :podcasts
  end

  test "active_subscription? returns true when active" do
    user = User.new(subscription_status: 'active')
    assert user.active_subscription?
  end
end
```

Create `test/models/podcast_test.rb`:
```ruby
require "test_helper"

class PodcastTest < ActiveSupport::TestCase
  test "generates podcast_id on creation" do
    user = User.create!(email: "test@example.com", password: "password")
    podcast = Podcast.create!
    podcast.users << user

    assert_match /^podcast_[a-f0-9]{16}$/, podcast.podcast_id
  end

  test "feed_url returns correct URL" do
    podcast = Podcast.create!(podcast_id: "podcast_test123")

    ENV['GOOGLE_CLOUD_BUCKET'] = 'test-bucket'
    expected = "https://storage.googleapis.com/test-bucket/podcasts/podcast_test123/feed.xml"

    assert_equal expected, podcast.feed_url
  end
end
```

Create `test/models/episode_test.rb`:
```ruby
require "test_helper"

class EpisodeTest < ActiveSupport::TestCase
  test "validates required fields" do
    episode = Episode.new
    assert_not episode.valid?
    assert_includes episode.errors[:title], "can't be blank"
    assert_includes episode.errors[:author], "can't be blank"
    assert_includes episode.errors[:description], "can't be blank"
  end

  test "audio_url returns URL when complete" do
    user = User.create!(email: "test@example.com", password: "password")
    podcast = Podcast.create!(podcast_id: "podcast_xyz")
    podcast.users << user

    episode = Episode.create!(
      podcast: podcast,
      title: "Test",
      author: "Author",
      description: "Description",
      status: "complete",
      gcs_episode_id: "episode_abc"
    )

    ENV['GOOGLE_CLOUD_BUCKET'] = 'test-bucket'
    expected = "https://storage.googleapis.com/test-bucket/podcasts/podcast_xyz/episodes/episode_abc.mp3"

    assert_equal expected, episode.audio_url
  end
end
```

**Step 11: Run tests**

Run:
```bash
rails test
```

Expected: All tests pass

**Step 12: Commit**

```bash
git add hub/
git commit -m "feat(hub): add Podcast, PodcastMembership, Episode models"
```

---

## Task 5: Auto-Create Podcast on User Signup ‚è∏Ô∏è

**Goal:** When user signs up, automatically create a podcast for them

**Status:** NOT STARTED - Depends on Tasks 3 & 4

**Step 1: Create User callback**

Edit `app/models/user.rb`, add after associations:
```ruby
  after_create :create_default_podcast

  private

  def create_default_podcast
    podcast = Podcast.create!(
      title: "#{email}'s Podcast",
      description: "My podcast created with TTS"
    )
    PodcastMembership.create!(user: self, podcast: podcast, role: 'owner')
  end
```

**Step 2: Write test**

Edit `test/models/user_test.rb`, add:
```ruby
  test "creates default podcast on signup" do
    user = User.create!(email: "new@example.com", password: "password")

    assert_equal 1, user.podcasts.count
    assert_equal "new@example.com's Podcast", user.podcasts.first.title
  end
```

**Step 3: Run test**

Run:
```bash
rails test test/models/user_test.rb
```

Expected: Test passes

**Step 4: Test manually**

Run server, sign up with a new email, check database:
```bash
rails console
User.last.podcasts
```

Expected: User has one podcast

**Step 5: Commit**

```bash
git add hub/
git commit -m "feat(hub): auto-create podcast on user signup"
```

---

## Task 6: Episodes Controller and Upload Form

**Goal:** Web UI to create episodes

**Step 1: Generate controller**

Run:
```bash
rails generate controller Episodes index new create
```

**Step 2: Update routes**

Edit `config/routes.rb`:
```ruby
Rails.application.routes.draw do
  root "episodes#index"

  resources :episodes, only: [:index, :new, :create]

  # Authentication routes (already there from generator)
  # ...
end
```

**Step 3: Create EpisodesController**

Edit `app/controllers/episodes_controller.rb`:
```ruby
class EpisodesController < ApplicationController
  before_action :require_authentication
  before_action :load_podcast

  def index
    @episodes = @podcast.episodes.recent
  end

  def new
    @episode = @podcast.episodes.build
  end

  def create
    @episode = @podcast.episodes.build(episode_params)

    if @episode.save
      # TODO: Enqueue processing job
      redirect_to episodes_path, notice: "Episode created! Processing..."
    else
      render :new, status: :unprocessable_entity
    end
  end

  private

  def load_podcast
    @podcast = current_user.podcasts.first
    redirect_to root_path, alert: "No podcast found" unless @podcast
  end

  def episode_params
    params.require(:episode).permit(:title, :author, :description, :content)
  end
end
```

**Step 4: Create index view**

Edit `app/views/episodes/index.html.erb`:
```erb
<div class="max-w-6xl mx-auto px-4 py-8">
  <div class="flex justify-between items-center mb-8">
    <div>
      <h1 class="text-3xl font-bold">Episodes</h1>
      <p class="text-gray-600 mt-2">
        RSS Feed: <%= link_to @podcast.feed_url, @podcast.feed_url, class: "text-blue-600 hover:underline", target: "_blank" %>
      </p>
    </div>
    <%= link_to "New Episode", new_episode_path, class: "bg-blue-600 text-white px-6 py-2 rounded-lg hover:bg-blue-700" %>
  </div>

  <% if @episodes.any? %>
    <div class="bg-white shadow rounded-lg overflow-hidden">
      <table class="min-w-full divide-y divide-gray-200">
        <thead class="bg-gray-50">
          <tr>
            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Title</th>
            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Author</th>
            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Status</th>
            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Created</th>
          </tr>
        </thead>
        <tbody class="bg-white divide-y divide-gray-200">
          <% @episodes.each do |episode| %>
            <tr>
              <td class="px-6 py-4"><%= episode.title %></td>
              <td class="px-6 py-4"><%= episode.author %></td>
              <td class="px-6 py-4">
                <span class="px-2 py-1 text-xs rounded-full <%= status_class(episode.status) %>">
                  <%= episode.status %>
                </span>
              </td>
              <td class="px-6 py-4 text-sm text-gray-500">
                <%= episode.created_at.strftime("%b %d, %Y") %>
              </td>
            </tr>
          <% end %>
        </tbody>
      </table>
    </div>
  <% else %>
    <div class="text-center py-12 bg-gray-50 rounded-lg">
      <p class="text-gray-600 mb-4">No episodes yet. Create your first episode!</p>
      <%= link_to "Create Episode", new_episode_path, class: "bg-blue-600 text-white px-6 py-2 rounded-lg hover:bg-blue-700 inline-block" %>
    </div>
  <% end %>
</div>
```

**Step 5: Create helper for status styling**

Edit `app/helpers/episodes_helper.rb`:
```ruby
module EpisodesHelper
  def status_class(status)
    case status
    when 'pending'
      'bg-yellow-100 text-yellow-800'
    when 'processing'
      'bg-blue-100 text-blue-800'
    when 'complete'
      'bg-green-100 text-green-800'
    when 'failed'
      'bg-red-100 text-red-800'
    else
      'bg-gray-100 text-gray-800'
    end
  end
end
```

**Step 6: Create new episode form**

Edit `app/views/episodes/new.html.erb`:
```erb
<div class="max-w-2xl mx-auto px-4 py-8">
  <h1 class="text-3xl font-bold mb-8">Create New Episode</h1>

  <%= form_with model: @episode, url: episodes_path, local: true, multipart: true, class: "space-y-6" do |f| %>
    <% if @episode.errors.any? %>
      <div class="bg-red-50 border border-red-200 rounded p-4">
        <h3 class="text-red-800 font-medium">Please fix the following errors:</h3>
        <ul class="list-disc list-inside mt-2 text-red-700">
          <% @episode.errors.full_messages.each do |message| %>
            <li><%= message %></li>
          <% end %>
        </ul>
      </div>
    <% end %>

    <div>
      <%= f.label :title, class: "block text-sm font-medium text-gray-700 mb-2" %>
      <%= f.text_field :title, class: "w-full border border-gray-300 rounded px-4 py-2", placeholder: "My Awesome Episode" %>
    </div>

    <div>
      <%= f.label :author, class: "block text-sm font-medium text-gray-700 mb-2" %>
      <%= f.text_field :author, class: "w-full border border-gray-300 rounded px-4 py-2", placeholder: "Your Name" %>
    </div>

    <div>
      <%= f.label :description, class: "block text-sm font-medium text-gray-700 mb-2" %>
      <%= f.text_area :description, rows: 3, class: "w-full border border-gray-300 rounded px-4 py-2", placeholder: "A brief description of this episode..." %>
    </div>

    <div>
      <%= f.label :content, "Markdown Content", class: "block text-sm font-medium text-gray-700 mb-2" %>
      <%= f.file_field :content, accept: ".md,.markdown,.txt", class: "w-full" %>
      <p class="mt-1 text-sm text-gray-500">Upload a markdown file (.md) with your article content</p>
    </div>

    <div class="flex gap-4">
      <%= f.submit "Create Episode", class: "bg-blue-600 text-white px-6 py-2 rounded-lg hover:bg-blue-700" %>
      <%= link_to "Cancel", episodes_path, class: "px-6 py-2 text-gray-600 hover:text-gray-800" %>
    </div>
  <% end %>
</div>
```

**Step 7: Test manually**

Run server, visit `/episodes/new`, fill out form.

Expected: Episode created (status: pending)

**Step 8: Commit**

```bash
git add hub/
git commit -m "feat(hub): add episodes controller and upload form"
```

---

## Task 7: Add Google Cloud Dependencies

**Goal:** Add GCS and Cloud Tasks gems

**Step 1: Add gems**

Edit `Gemfile`:
```ruby
gem "google-cloud-storage", "~> 1.47"
gem "google-cloud-tasks", "~> 2.6"
```

**Step 2: Install**

Run:
```bash
bundle install
```

**Step 3: Update Kamal secrets**

Edit `.kamal/secrets`:
```bash
GOOGLE_CLOUD_PROJECT=$(kamal secrets fetch GOOGLE_CLOUD_PROJECT)
GOOGLE_CLOUD_BUCKET=$(kamal secrets fetch GOOGLE_CLOUD_BUCKET)
CLOUD_TASKS_LOCATION=$(kamal secrets fetch CLOUD_TASKS_LOCATION)
CLOUD_TASKS_QUEUE=$(kamal secrets fetch CLOUD_TASKS_QUEUE)
GENERATOR_SERVICE_URL=$(kamal secrets fetch GENERATOR_SERVICE_URL)
GENERATOR_CALLBACK_SECRET=$(kamal secrets fetch GENERATOR_CALLBACK_SECRET)
```

**Step 4: Commit**

```bash
git add hub/
git commit -m "feat(hub): add Google Cloud gems"
```

---

## Task 8: Implement Episode Processing Flow

**Goal:** Upload markdown to GCS, enqueue Cloud Task to Generator

**Step 1: Create GCS upload service**

Create `app/services/gcs_uploader.rb`:
```ruby
require 'google/cloud/storage'

class GcsUploader
  def initialize(bucket_name, podcast_id:)
    @bucket_name = bucket_name
    @podcast_id = podcast_id
    @storage = Google::Cloud::Storage.new
  end

  def upload_staging_file(content:, filename:)
    path = "podcasts/#{@podcast_id}/staging/#{filename}"
    bucket.create_file(StringIO.new(content), path)
    path
  end

  private

  def bucket
    @bucket ||= @storage.bucket(@bucket_name)
  end
end
```

**Step 2: Create Cloud Tasks enqueuer**

Create `app/services/cloud_tasks_enqueuer.rb`:
```ruby
require 'google/cloud/tasks'

class CloudTasksEnqueuer
  def enqueue_episode_processing(episode_id:, podcast_id:, staging_path:, metadata:)
    client = Google::Cloud::Tasks.cloud_tasks

    parent = client.queue_path(
      project: ENV.fetch('GOOGLE_CLOUD_PROJECT'),
      location: ENV.fetch('CLOUD_TASKS_LOCATION'),
      queue: ENV.fetch('CLOUD_TASKS_QUEUE')
    )

    task = {
      http_request: {
        http_method: 'POST',
        url: "#{ENV.fetch('GENERATOR_SERVICE_URL')}/process",
        headers: { 'Content-Type' => 'application/json' },
        body: {
          episode_id: episode_id,
          podcast_id: podcast_id,
          staging_path: staging_path,
          title: metadata[:title],
          author: metadata[:author],
          description: metadata[:description]
        }.to_json,
        oidc_token: {
          service_account_email: "#{ENV.fetch('GOOGLE_CLOUD_PROJECT')}@appspot.gserviceaccount.com"
        }
      }
    }

    client.create_task(parent: parent, task: task)
  end
end
```

**Step 3: Update EpisodesController create action**

Edit `app/controllers/episodes_controller.rb`:
```ruby
  def create
    @episode = @podcast.episodes.build(episode_params.except(:content))

    if @episode.save
      # Upload to GCS staging
      content = params[:episode][:content].read
      filename = "#{@episode.id}-#{Time.now.to_i}.md"

      uploader = GcsUploader.new(
        ENV.fetch('GOOGLE_CLOUD_BUCKET'),
        podcast_id: @podcast.podcast_id
      )
      staging_path = uploader.upload_staging_file(content: content, filename: filename)

      # Enqueue processing
      CloudTasksEnqueuer.new.enqueue_episode_processing(
        episode_id: @episode.id,
        podcast_id: @podcast.podcast_id,
        staging_path: staging_path,
        metadata: {
          title: @episode.title,
          author: @episode.author,
          description: @episode.description
        }
      )

      redirect_to episodes_path, notice: "Episode created! Processing..."
    else
      render :new, status: :unprocessable_entity
    end
  end
```

**Step 4: Commit**

```bash
git add hub/
git commit -m "feat(hub): implement episode processing with GCS and Cloud Tasks"
```

---

## Task 9: Add Generator Callback Endpoint

**Goal:** Endpoint for Generator to update episode status

**Step 1: Create Internal API controller**

Create `app/controllers/api/internal/episodes_controller.rb`:
```ruby
module Api
  module Internal
    class EpisodesController < ApplicationController
      skip_before_action :require_authentication
      before_action :verify_generator_secret

      def complete
        episode = Episode.find(params[:id])

        episode.update!(
          status: 'complete',
          gcs_episode_id: params[:gcs_episode_id],
          audio_size_bytes: params[:audio_size_bytes],
          duration_seconds: params[:duration_seconds]
        )

        render json: { status: 'success' }
      end

      def failed
        episode = Episode.find(params[:id])

        episode.update!(
          status: 'failed',
          error_message: params[:error_message]
        )

        render json: { status: 'success' }
      end

      private

      def verify_generator_secret
        secret = request.headers['X-Generator-Secret']
        expected = ENV.fetch('GENERATOR_CALLBACK_SECRET')

        unless secret == expected
          render json: { error: 'Unauthorized' }, status: :unauthorized
        end
      end
    end
  end
end
```

**Step 2: Add routes**

Edit `config/routes.rb`:
```ruby
  namespace :api do
    namespace :internal do
      post 'episodes/:id/complete', to: 'episodes#complete'
      post 'episodes/:id/failed', to: 'episodes#failed'
    end
  end
```

**Step 3: Test with curl**

```bash
curl -X POST http://localhost:3000/api/internal/episodes/1/complete \
  -H "X-Generator-Secret: test-secret" \
  -H "Content-Type: application/json" \
  -d '{"gcs_episode_id":"episode_abc","audio_size_bytes":1000000,"duration_seconds":300}'
```

**Step 4: Commit**

```bash
git add hub/
git commit -m "feat(hub): add Generator callback endpoints"
```

---

## Task 10: Update Generator Service

**Goal:** Remove podcast_id generation from Generator, validate it's provided

**Step 1: Update Generator to validate podcast_id**

Edit `generator/lib/episode_processor.rb`:
```ruby
  def initialize(bucket_name = nil, podcast_id = nil)
    @bucket_name = bucket_name || ENV.fetch("GOOGLE_CLOUD_BUCKET")
    @podcast_id = podcast_id

    raise ArgumentError, "podcast_id is required and must be provided by Hub" unless @podcast_id

    # Remove podcast_id validation/generation logic
    # Hub is now source of truth
  end
```

**Step 2: Update Generator to call Hub on completion**

Edit `generator/lib/episode_processor.rb`, add at end of `process` method:
```ruby
  def process(title:, author:, description:, markdown_content:)
    # ... existing processing ...

    # Callback to Hub
    notify_hub_complete(
      episode_id: @episode_id,
      gcs_episode_id: episode_id,
      audio_size_bytes: audio_content.bytesize,
      duration_seconds: estimate_duration(audio_content.bytesize)
    )
  end

  private

  def notify_hub_complete(episode_id:, gcs_episode_id:, audio_size_bytes:, duration_seconds:)
    uri = URI("#{ENV.fetch('HUB_CALLBACK_URL')}/api/internal/episodes/#{episode_id}/complete")

    http = Net::HTTP.new(uri.host, uri.port)
    http.use_ssl = uri.scheme == 'https'

    request = Net::HTTP::Post.new(uri.path)
    request['X-Generator-Secret'] = ENV.fetch('GENERATOR_CALLBACK_SECRET')
    request['Content-Type'] = 'application/json'
    request.body = {
      gcs_episode_id: gcs_episode_id,
      audio_size_bytes: audio_size_bytes,
      duration_seconds: duration_seconds
    }.to_json

    http.request(request)
  end

  def estimate_duration(audio_size_bytes)
    # Rough estimate: MP3 at 128kbps = ~16KB/sec
    (audio_size_bytes / 16_000).to_i
  end
```

**Step 3: Update Generator /process endpoint**

Edit `generator/api.rb`:
```ruby
post "/process" do
  request.body.rewind
  payload = JSON.parse(request.body.read)

  # Extract episode_id from Hub
  episode_id = payload["episode_id"]
  podcast_id = payload["podcast_id"]
  staging_path = payload["staging_path"]
  title = payload["title"]
  author = payload["author"]
  description = payload["description"]

  # Download from staging
  gcs = GCSUploader.new(ENV.fetch("GOOGLE_CLOUD_BUCKET"), podcast_id: podcast_id)
  markdown_content = gcs.download_file(remote_path: staging_path)

  # Process
  processor = EpisodeProcessor.new(ENV.fetch("GOOGLE_CLOUD_BUCKET"), podcast_id, episode_id)
  processor.process(
    title: title,
    author: author,
    description: description,
    markdown_content: markdown_content
  )

  # Cleanup staging
  gcs.delete_file(remote_path: staging_path)

  json status: "success"
rescue StandardError => e
  # Notify Hub of failure
  notify_hub_failed(episode_id, e.message)
  halt 500, json(status: "error", message: e.message)
end
```

**Step 4: Commit Generator changes**

```bash
git add generator/
git commit -m "feat(generator): remove podcast_id generation, add Hub callbacks"
```

---

## Task 11: End-to-End Testing

**Goal:** Verify complete flow works

**Step 1: Test local episode creation**

1. Start Hub: `cd hub && rails server`
2. Sign up with email
3. Create episode with markdown file
4. Verify episode shows as "pending"

**Step 2: Test with local Generator**

1. Set up local Generator environment
2. Manually trigger processing
3. Verify episode status updates to "complete"
4. Verify RSS feed URL works

**Step 3: Deploy and test**

1. Deploy Hub: `cd hub && kamal deploy`
2. Deploy Generator: `cd generator && ./bin/deploy`
3. Create episode via web UI
4. Monitor Cloud Tasks queue
5. Verify end-to-end flow

---

## Completion Checklist

- [ ] User can sign up with magic link
- [ ] User automatically gets a podcast
- [ ] User can upload markdown episode
- [ ] Episode uploads to GCS staging
- [ ] Cloud Task enqueued to Generator
- [ ] Generator processes episode
- [ ] Generator calls back to Hub
- [ ] Episode status updates to complete
- [ ] RSS feed URL displayed
- [ ] All tests pass

---

## Next Steps (After MVP)

- Add Stripe billing
- Add API key generation
- Add marketing landing page
- Add ability to create additional podcasts
- Add podcast collaboration features
- Add episode editing/deletion
- Add podcast settings/customization

# Async Audio Generation Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Move TTS audio generation to a separate background job to eliminate SQLite lock contention.

**Architecture:** Extract `GeneratesEpisodeAudio` call from `SubmitsEpisodeForProcessing` into a new `GeneratesEpisodeAudioJob`. This releases the database write lock immediately after saving episode metadata, before the long-running TTS synthesis begins.

**Tech Stack:** Rails 8, SolidQueue, ActiveJob, Mocktail (testing)

---

## Task 1: Create GeneratesEpisodeAudioJob

**Files:**
- Create: `app/jobs/generates_episode_audio_job.rb`
- Create: `test/jobs/generates_episode_audio_job_test.rb`

**Step 1: Write the failing test**

Create `test/jobs/generates_episode_audio_job_test.rb`:

```ruby
# frozen_string_literal: true

require "test_helper"

class GeneratesEpisodeAudioJobTest < ActiveSupport::TestCase
  include ActiveJob::TestHelper
  include Mocktail::DSL

  setup do
    @episode = episodes(:one)
    @episode.update!(source_text: "Test content", status: :processing)
    Mocktail.replace(GeneratesEpisodeAudio)
  end

  teardown do
    Mocktail.reset
  end

  test "can be enqueued" do
    assert_enqueued_with(job: GeneratesEpisodeAudioJob) do
      GeneratesEpisodeAudioJob.perform_later(episode_id: @episode.id)
    end
  end

  test "calls GeneratesEpisodeAudio with episode" do
    stubs { |m| GeneratesEpisodeAudio.call(episode: m.any) }.with { nil }

    GeneratesEpisodeAudioJob.perform_now(episode_id: @episode.id)

    assert_equal 1, Mocktail.calls(GeneratesEpisodeAudio, :call).size
    call = Mocktail.calls(GeneratesEpisodeAudio, :call).first
    assert_equal @episode.id, call.args[:episode].id
  end

  test "sets Current.action_id when provided" do
    stubs { |m| GeneratesEpisodeAudio.call(episode: m.any) }.with { nil }

    GeneratesEpisodeAudioJob.perform_now(episode_id: @episode.id, action_id: "test-action-123")

    assert_equal "test-action-123", Current.action_id
  end
end
```

**Step 2: Run test to verify it fails**

Run: `bin/rails test test/jobs/generates_episode_audio_job_test.rb`

Expected: Error - `uninitialized constant GeneratesEpisodeAudioJob`

**Step 3: Write minimal implementation**

Create `app/jobs/generates_episode_audio_job.rb`:

```ruby
# frozen_string_literal: true

class GeneratesEpisodeAudioJob < ApplicationJob
  include EpisodeJobLogging

  queue_as :default
  limits_concurrency to: 1, key: ->(episode_id:, **) { Episode.find(episode_id).user_id }

  def perform(episode_id:, action_id: nil)
    with_episode_logging(episode_id: episode_id, user_id: nil, action_id: action_id) do
      episode = Episode.find(episode_id)
      GeneratesEpisodeAudio.call(episode: episode)
    end
  end
end
```

**Step 4: Run test to verify it passes**

Run: `bin/rails test test/jobs/generates_episode_audio_job_test.rb`

Expected: All 3 tests pass

**Step 5: Commit**

```bash
git add app/jobs/generates_episode_audio_job.rb test/jobs/generates_episode_audio_job_test.rb
git commit -m "feat: add GeneratesEpisodeAudioJob for async TTS processing"
```

---

## Task 2: Update SubmitsEpisodeForProcessing to enqueue job

**Files:**
- Modify: `app/services/submits_episode_for_processing.rb`
- Modify: `test/services/submits_episode_for_processing_test.rb`

**Step 1: Update the test to expect job enqueue instead of direct call**

Modify `test/services/submits_episode_for_processing_test.rb`:

```ruby
# frozen_string_literal: true

require "test_helper"

class SubmitsEpisodeForProcessingTest < ActiveSupport::TestCase
  include ActiveJob::TestHelper

  setup do
    @episode = episodes(:one)
    @episode.update!(title: "Test Title", author: "Test Author")
    @episode.user.update!(account_type: :standard)
  end

  test "enqueues GeneratesEpisodeAudioJob" do
    assert_enqueued_with(job: GeneratesEpisodeAudioJob, args: { episode_id: @episode.id, action_id: nil }) do
      SubmitsEpisodeForProcessing.call(episode: @episode, content: "Article body.")
    end
  end

  test "stores wrapped content in source_text" do
    perform_enqueued_jobs do
      # Stub the audio generation since we're not testing that here
      GeneratesEpisodeAudio.stub(:call, nil) do
        SubmitsEpisodeForProcessing.call(episode: @episode, content: "Article body.")
      end
    end

    @episode.reload
    assert @episode.source_text.include?("Test Title")
    assert @episode.source_text.include?("Article body.")
  end

  test "includes free tier attribution for free users" do
    SubmitsEpisodeForProcessing.call(episode: @episode, content: "Article body.")

    @episode.reload
    assert @episode.source_text.include?("This audio was generated by Very Normal TTS")
  end

  test "excludes free tier attribution for premium users" do
    @episode.user.update!(account_type: :complimentary)

    SubmitsEpisodeForProcessing.call(episode: @episode, content: "Article body.")

    @episode.reload
    refute @episode.source_text.include?("This audio was generated by Very Normal TTS")
  end

  test "passes action_id to job" do
    Current.action_id = "test-action-456"

    assert_enqueued_with(job: GeneratesEpisodeAudioJob, args: { episode_id: @episode.id, action_id: "test-action-456" }) do
      SubmitsEpisodeForProcessing.call(episode: @episode, content: "Article body.")
    end
  ensure
    Current.action_id = nil
  end
end
```

**Step 2: Run test to verify it fails**

Run: `bin/rails test test/services/submits_episode_for_processing_test.rb`

Expected: Failures - tests expect job to be enqueued but service still calls `GeneratesEpisodeAudio` directly

**Step 3: Update implementation**

Modify `app/services/submits_episode_for_processing.rb`:

```ruby
# frozen_string_literal: true

class SubmitsEpisodeForProcessing
  include EpisodeLogging

  def self.call(episode:, content:)
    new(episode: episode, content: content).call
  end

  def initialize(episode:, content:)
    @episode = episode
    @content = content
  end

  def call
    log_info "submit_episode_for_processing", podcast_id: episode.podcast.podcast_id

    wrapped = wrap_content
    episode.update!(source_text: wrapped)

    GeneratesEpisodeAudioJob.perform_later(episode_id: episode.id, action_id: Current.action_id)

    log_info "audio_generation_enqueued"
  end

  private

  attr_reader :episode, :content

  def wrap_content
    BuildsEpisodeWrapper.call(
      title: episode.title,
      author: episode.author,
      include_attribution: episode.user.free?,
      content: content
    )
  end
end
```

**Step 4: Run test to verify it passes**

Run: `bin/rails test test/services/submits_episode_for_processing_test.rb`

Expected: All 5 tests pass

**Step 5: Run full test suite**

Run: `bin/rails test`

Expected: All tests pass (some tests may need adjustment if they were relying on synchronous audio generation)

**Step 6: Commit**

```bash
git add app/services/submits_episode_for_processing.rb test/services/submits_episode_for_processing_test.rb
git commit -m "refactor: enqueue audio generation as separate job

This moves TTS synthesis out of the database transaction, fixing
SQLite lock contention when multiple users create episodes
simultaneously."
```

---

## Task 3: Verify integration and cleanup

**Files:**
- Review: `test/jobs/processes_url_episode_job_test.rb`
- Review: `test/jobs/processes_file_episode_job_test.rb`
- Review: `test/jobs/processes_paste_episode_job_test.rb`

**Step 1: Run all job tests**

Run: `bin/rails test test/jobs/`

Expected: All tests pass. The existing job tests should still work because they mock at the `FetchesUrl` level, failing before reaching `SubmitsEpisodeForProcessing`.

**Step 2: Run full test suite**

Run: `bin/rails test`

Expected: All tests pass

**Step 3: Manual verification (optional)**

If you have a local development environment:

1. Start the server: `bin/dev`
2. Create an episode from URL
3. Observe in logs:
   - `submit_episode_for_processing` log line
   - `audio_generation_enqueued` log line
   - Then separately: `generates_episode_audio_job_started` log line
4. Verify episode completes successfully

**Step 4: Final commit (if any test fixes were needed)**

```bash
git add -A
git commit -m "test: fix tests for async audio generation"
```

---

## Summary

| Change | Purpose |
|--------|---------|
| New `GeneratesEpisodeAudioJob` | Wraps existing service, runs TTS outside any transaction |
| Modified `SubmitsEpisodeForProcessing` | Enqueues job instead of calling service directly |
| Updated tests | Verify job is enqueued, not called synchronously |

**Result:** Database write lock is released immediately after saving episode metadata. TTS runs in a separate job with its own connection, eliminating lock contention.

# frozen_string_literal: true

require "test_helper"

class SubmitEpisodeForProcessingTest < ActiveSupport::TestCase
  setup do
    @episode = episodes(:one)
    @episode.update!(title: "Test Title", author: "Test Author")
    @episode.user.update!(tier: :free)
    ENV["GOOGLE_CLOUD_BUCKET"] = "test-bucket"

    Mocktail.replace(GcsUploader)
    Mocktail.replace(CloudTasksEnqueuer)
    Mocktail.replace(GenerateAudioJob)
  end

  test "wraps content, uploads, and enqueues for processing" do
    mock_gcs = Mocktail.of(GcsUploader)
    stubs { |m| mock_gcs.upload_staging_file(content: m.any, filename: m.any) }.with { "staging/test.txt" }
    stubs { |m| GcsUploader.new(m.any, podcast_id: m.any) }.with { mock_gcs }

    mock_tasks = Mocktail.of(CloudTasksEnqueuer)
    stubs { |m| mock_tasks.enqueue_episode_processing(episode_id: m.any, podcast_id: m.any, staging_path: m.any, metadata: m.any, voice_name: m.any) }.with { "task-123" }
    stubs { CloudTasksEnqueuer.new }.with { mock_tasks }

    SubmitEpisodeForProcessing.call(episode: @episode, content: "Article body.")

    expected_content = <<~EXPECTED.strip
      Test Title; by Test Author. This audio was generated by Very Normal TTS.

      Article body.

      Thank you for listening to this Very Normal TTS generated audio.
    EXPECTED

    verify { |m| mock_gcs.upload_staging_file(content: expected_content, filename: m.any) }
    verify { |m| mock_tasks.enqueue_episode_processing(episode_id: @episode.id, podcast_id: m.any, staging_path: "staging/test.txt", metadata: m.any, voice_name: m.any) }
  end

  test "wraps content without free tier attribution for premium users" do
    @episode.user.update!(tier: :premium)

    mock_gcs = Mocktail.of(GcsUploader)
    stubs { |m| mock_gcs.upload_staging_file(content: m.any, filename: m.any) }.with { "staging/test.txt" }
    stubs { |m| GcsUploader.new(m.any, podcast_id: m.any) }.with { mock_gcs }

    mock_tasks = Mocktail.of(CloudTasksEnqueuer)
    stubs { |m| mock_tasks.enqueue_episode_processing(episode_id: m.any, podcast_id: m.any, staging_path: m.any, metadata: m.any, voice_name: m.any) }.with { "task-123" }
    stubs { CloudTasksEnqueuer.new }.with { mock_tasks }

    SubmitEpisodeForProcessing.call(episode: @episode, content: "Article body.")

    expected_content = <<~EXPECTED.strip
      Test Title; by Test Author.

      Article body.

      Thank you for listening to this Very Normal TTS generated audio.
    EXPECTED

    verify { |m| mock_gcs.upload_staging_file(content: expected_content, filename: m.any) }
  end

  test "logs staging upload and enqueue events" do
    mock_gcs = Mocktail.of(GcsUploader)
    stubs { |m| mock_gcs.upload_staging_file(content: m.any, filename: m.any) }.with { "staging/test.txt" }
    stubs { |m| GcsUploader.new(m.any, podcast_id: m.any) }.with { mock_gcs }

    mock_tasks = Mocktail.of(CloudTasksEnqueuer)
    stubs { |m| mock_tasks.enqueue_episode_processing(episode_id: m.any, podcast_id: m.any, staging_path: m.any, metadata: m.any, voice_name: m.any) }.with { "task-123" }
    stubs { CloudTasksEnqueuer.new }.with { mock_tasks }

    # Just verify it doesn't raise - logging is a side effect
    assert_nothing_raised do
      SubmitEpisodeForProcessing.call(episode: @episode, content: "Test content")
    end
  end

  test "uses internal TTS for allowlisted podcasts" do
    @episode.podcast.update!(podcast_id: "podcast_195c82bf8eeb2aae")
    stubs { |m| GenerateAudioJob.perform_later(m.any) }.with { nil }

    SubmitEpisodeForProcessing.call(episode: @episode, content: "Test content")

    # Verify GenerateAudioJob was called, not the external path
    assert_equal 1, Mocktail.calls(GenerateAudioJob, :perform_later).size
    assert_equal 0, Mocktail.calls(CloudTasksEnqueuer, :new).size
  end

  test "uses external generator for non-allowlisted podcasts" do
    @episode.podcast.update!(podcast_id: "podcast_other")

    mock_gcs = Mocktail.of(GcsUploader)
    stubs { |m| mock_gcs.upload_staging_file(content: m.any, filename: m.any) }.with { "staging/test.txt" }
    stubs { |m| GcsUploader.new(m.any, podcast_id: m.any) }.with { mock_gcs }

    mock_tasks = Mocktail.of(CloudTasksEnqueuer)
    stubs { |m| mock_tasks.enqueue_episode_processing(episode_id: m.any, podcast_id: m.any, staging_path: m.any, metadata: m.any, voice_name: m.any) }.with { "task-123" }
    stubs { CloudTasksEnqueuer.new }.with { mock_tasks }

    SubmitEpisodeForProcessing.call(episode: @episode, content: "Test content")

    # Verify external path was used, not GenerateAudioJob
    assert_equal 0, Mocktail.calls(GenerateAudioJob, :perform_later).size
    assert_equal 1, Mocktail.calls(CloudTasksEnqueuer, :new).size
  end

  test "stores wrapped content in source_text for internal TTS" do
    @episode.podcast.update!(podcast_id: "podcast_195c82bf8eeb2aae")
    stubs { |m| GenerateAudioJob.perform_later(m.any) }.with { nil }

    SubmitEpisodeForProcessing.call(episode: @episode, content: "Article body.")

    @episode.reload
    assert @episode.source_text.include?("Test Title")
    assert @episode.source_text.include?("Article body.")
  end
end

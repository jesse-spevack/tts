# URL-to-TTS Feature Implementation Plan

## Progress Summary (for context restoration)

**Branch:** `url-to-tts` (PR #37 draft)

**Completed:**
- Tasks 1-9: All backend services implemented
- LlmClient, RecordLlmUsage extracted from LlmProcessor
- UploadAndEnqueueEpisode, MaxCharactersForUser, EpisodeLogging extracted from ProcessUrlEpisode
- Using Gemini 2.0 Flash via Vertex AI (us-central1 region)
- All tests passing (201 tests)

**Refactoring done:**
- Mocktail for all mocking (no constructor injection)
- EpisodeLogging concern with abstract `episode` method

**Key env vars:**
- `GOOGLE_CLOUD_PROJECT=very-normal`
- `VERTEX_AI_LOCATION=us-central1` (not us-west3 - Gemini unavailable there)
- `GOOGLE_APPLICATION_CREDENTIALS` (local dev only, VM uses ADC)

**Remaining tasks:**
- Task 10: CreateUrlEpisode service
- Task 11: Update controller for URL submissions
- Task 12: View with segmented control UI (file/URL toggle)
- Task 13: Episode card shows source URL
- Task 14: Environment docs
- Task 15: Full test suite

**Test scripts:**
- `bin/test_llm_client` - tests LLM connectivity
- `bin/test_url_processing <url>` - tests full pipeline

---

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Allow users to submit a URL instead of a markdown file, automatically extracting and processing article content for TTS conversion.

**Architecture:** Hub handles all URL processing (fetch, extract, LLM cleanup). Fully async: user submits URL, sees "processing" immediately, background job does the work. Generator remains unchanged.

**Tech Stack:** ruby_llm gem (Vertex AI for Gemini/Claude), Faraday for HTTP, Nokogiri for extraction, Solid Queue for background jobs.

---

## Task 1: Add ruby_llm and faraday gems

Add the core dependencies for LLM integration and HTTP fetching.

**Files:**
- Modify: `hub/Gemfile`

**Step 1: Add gems to Gemfile**

Add after the Google Cloud services section (line 47):

```ruby
# LLM integration
gem "ruby_llm"
gem "faraday"
gem "faraday-follow_redirects"
```

**Step 2: Install gems**

Run: `cd hub && bundle install`
Expected: Gems install successfully

**Step 3: Commit**

```bash
git add hub/Gemfile hub/Gemfile.lock
git commit -m "chore: add ruby_llm and faraday gems"
```

---

## Task 2: Create LlmUsage model and migration

Track LLM token usage and costs per episode for billing visibility and cost monitoring.

**Files:**
- Create: `hub/db/migrate/TIMESTAMP_create_llm_usages.rb`
- Create: `hub/app/models/llm_usage.rb`
- Create: `hub/test/models/llm_usage_test.rb`

**Step 1: Write the failing test**

Create `hub/test/models/llm_usage_test.rb`:

```ruby
require "test_helper"

class LlmUsageTest < ActiveSupport::TestCase
  test "belongs to episode" do
    usage = LlmUsage.new(
      episode: episodes(:one),
      model_id: "claude-3-haiku",
      provider: "vertex_ai",
      input_tokens: 1000,
      output_tokens: 500,
      cost_cents: 0.05
    )
    assert usage.valid?
    assert_equal episodes(:one), usage.episode
  end

  test "requires episode" do
    usage = LlmUsage.new(
      model_id: "claude-3-haiku",
      provider: "vertex_ai",
      input_tokens: 1000,
      output_tokens: 500,
      cost_cents: 0.05
    )
    assert_not usage.valid?
    assert_includes usage.errors[:episode], "must exist"
  end

  test "requires model_id" do
    usage = LlmUsage.new(
      episode: episodes(:one),
      provider: "vertex_ai",
      input_tokens: 1000,
      output_tokens: 500
    )
    assert_not usage.valid?
    assert_includes usage.errors[:model_id], "can't be blank"
  end

  test "requires provider" do
    usage = LlmUsage.new(
      episode: episodes(:one),
      model_id: "claude-3-haiku",
      input_tokens: 1000,
      output_tokens: 500
    )
    assert_not usage.valid?
    assert_includes usage.errors[:provider], "can't be blank"
  end

  test "cost_dollars converts cents to dollars" do
    usage = LlmUsage.new(cost_cents: 5.25)
    assert_equal 0.0525, usage.cost_dollars
  end
end
```

**Step 2: Run test to verify it fails**

Run: `cd hub && bin/rails test test/models/llm_usage_test.rb`
Expected: FAIL - "uninitialized constant LlmUsage"

**Step 3: Generate migration**

Run: `cd hub && bin/rails generate migration CreateLlmUsages`

Edit the generated migration file:

```ruby
class CreateLlmUsages < ActiveRecord::Migration[8.1]
  def change
    create_table :llm_usages do |t|
      t.references :episode, null: false, foreign_key: true
      t.string :model_id, null: false
      t.string :provider, null: false
      t.integer :input_tokens, null: false
      t.integer :output_tokens, null: false
      t.decimal :cost_cents, precision: 10, scale: 4

      t.timestamps
    end
  end
end
```

**Step 4: Run migration**

Run: `cd hub && bin/rails db:migrate`
Expected: Migration completes successfully

**Step 5: Create model**

Create `hub/app/models/llm_usage.rb`:

```ruby
class LlmUsage < ApplicationRecord
  belongs_to :episode

  validates :model_id, presence: true
  validates :provider, presence: true
  validates :input_tokens, presence: true
  validates :output_tokens, presence: true

  def cost_dollars
    (cost_cents || 0) / 100.0
  end
end
```

**Step 6: Add association to Episode**

Modify `hub/app/models/episode.rb`, add after line 3:

```ruby
has_one :llm_usage, dependent: :destroy
```

**Step 7: Run tests to verify they pass**

Run: `cd hub && bin/rails test test/models/llm_usage_test.rb`
Expected: All tests PASS

**Step 8: Commit**

```bash
git add hub/db/migrate/*_create_llm_usages.rb hub/app/models/llm_usage.rb hub/app/models/episode.rb hub/test/models/llm_usage_test.rb hub/db/schema.rb
git commit -m "feat: add LlmUsage model for cost tracking"
```

---

## Task 3: Add source_url and source_type to episodes

Extend the Episode model to distinguish URL-sourced episodes from markdown uploads.

**Files:**
- Create: `hub/db/migrate/TIMESTAMP_add_source_fields_to_episodes.rb`
- Modify: `hub/app/models/episode.rb`
- Create: `hub/test/models/episode_source_test.rb`

**Step 1: Write the failing test**

Create `hub/test/models/episode_source_test.rb`:

```ruby
require "test_helper"

class EpisodeSourceTest < ActiveSupport::TestCase
  test "source_type defaults to markdown" do
    episode = Episode.new
    assert_equal "markdown", episode.source_type
  end

  test "source_type can be url" do
    episode = Episode.new(source_type: :url)
    assert episode.url?
    assert_not episode.markdown?
  end

  test "url source requires source_url" do
    episode = Episode.new(
      podcast: podcasts(:one),
      user: users(:one),
      title: "Test",
      author: "Test Author",
      description: "Test description",
      source_type: :url,
      source_url: nil
    )
    assert_not episode.valid?
    assert_includes episode.errors[:source_url], "can't be blank"
  end

  test "url source with source_url is valid" do
    episode = Episode.new(
      podcast: podcasts(:one),
      user: users(:one),
      title: "Test",
      author: "Test Author",
      description: "Test description",
      source_type: :url,
      source_url: "https://example.com/article"
    )
    assert episode.valid?
  end

  test "markdown source does not require source_url" do
    episode = Episode.new(
      podcast: podcasts(:one),
      user: users(:one),
      title: "Test",
      author: "Test Author",
      description: "Test description",
      source_type: :markdown
    )
    assert episode.valid?
  end
end
```

**Step 2: Run test to verify it fails**

Run: `cd hub && bin/rails test test/models/episode_source_test.rb`
Expected: FAIL - undefined method `source_type`

**Step 3: Generate migration**

Run: `cd hub && bin/rails generate migration AddSourceFieldsToEpisodes`

Edit the generated migration:

```ruby
class AddSourceFieldsToEpisodes < ActiveRecord::Migration[8.1]
  def change
    add_column :episodes, :source_url, :string
    add_column :episodes, :source_type, :integer, default: 0, null: false
  end
end
```

**Step 4: Run migration**

Run: `cd hub && bin/rails db:migrate`
Expected: Migration completes

**Step 5: Update Episode model**

Modify `hub/app/models/episode.rb`, add after line 5 (after status enum):

```ruby
enum :source_type, { markdown: 0, url: 1 }

validates :source_url, presence: true, if: :url?
```

**Step 6: Run tests to verify they pass**

Run: `cd hub && bin/rails test test/models/episode_source_test.rb`
Expected: All tests PASS

**Step 7: Commit**

```bash
git add hub/db/migrate/*_add_source_fields_to_episodes.rb hub/app/models/episode.rb hub/test/models/episode_source_test.rb hub/db/schema.rb
git commit -m "feat: add source_type and source_url to episodes"
```

---

## Task 4: Create UrlFetcher service

Fetch webpage HTML from URLs with timeout handling and redirect support.

**Files:**
- Create: `hub/app/services/url_fetcher.rb`
- Create: `hub/test/services/url_fetcher_test.rb`

**Step 1: Write the failing test**

Create `hub/test/services/url_fetcher_test.rb`:

```ruby
require "test_helper"

class UrlFetcherTest < ActiveSupport::TestCase
  test "fetches HTML from valid URL" do
    stub_request(:get, "https://example.com/article")
      .to_return(status: 200, body: "<html><body>Hello</body></html>", headers: { "Content-Type" => "text/html" })

    result = UrlFetcher.call(url: "https://example.com/article")

    assert result.success?
    assert_includes result.html, "Hello"
  end

  test "fails on invalid URL format" do
    result = UrlFetcher.call(url: "not-a-url")

    assert result.failure?
    assert_equal "Invalid URL", result.error
  end

  test "fails on connection timeout" do
    stub_request(:get, "https://example.com/slow")
      .to_timeout

    result = UrlFetcher.call(url: "https://example.com/slow")

    assert result.failure?
    assert_equal "Could not fetch URL", result.error
  end

  test "fails on 404 response" do
    stub_request(:get, "https://example.com/missing")
      .to_return(status: 404)

    result = UrlFetcher.call(url: "https://example.com/missing")

    assert result.failure?
    assert_equal "Could not fetch URL", result.error
  end

  test "fails on 500 response" do
    stub_request(:get, "https://example.com/error")
      .to_return(status: 500)

    result = UrlFetcher.call(url: "https://example.com/error")

    assert result.failure?
    assert_equal "Could not fetch URL", result.error
  end

  test "follows redirects" do
    stub_request(:get, "https://example.com/old")
      .to_return(status: 302, headers: { "Location" => "https://example.com/new" })
    stub_request(:get, "https://example.com/new")
      .to_return(status: 200, body: "<html><body>New page</body></html>")

    result = UrlFetcher.call(url: "https://example.com/old")

    assert result.success?
    assert_includes result.html, "New page"
  end
end
```

**Step 2: Add webmock to test helper**

Modify `hub/Gemfile`, add to test group:

```ruby
gem "webmock"
```

Run: `cd hub && bundle install`

Modify `hub/test/test_helper.rb`, add after requires:

```ruby
require "webmock/minitest"
```

**Step 3: Run test to verify it fails**

Run: `cd hub && bin/rails test test/services/url_fetcher_test.rb`
Expected: FAIL - "uninitialized constant UrlFetcher"

**Step 4: Create UrlFetcher service**

Create `hub/app/services/url_fetcher.rb`:

```ruby
class UrlFetcher
  TIMEOUT_SECONDS = 10

  def self.call(url:)
    new(url: url).call
  end

  def initialize(url:)
    @url = url
  end

  def call
    return Result.failure("Invalid URL") unless valid_url?

    response = connection.get(url)
    return Result.failure("Could not fetch URL") unless response.success?

    Result.success(response.body)
  rescue Faraday::TimeoutError, Faraday::ConnectionFailed
    Result.failure("Could not fetch URL")
  end

  private

  attr_reader :url

  def valid_url?
    uri = URI.parse(url)
    uri.is_a?(URI::HTTP) || uri.is_a?(URI::HTTPS)
  rescue URI::InvalidURIError
    false
  end

  def connection
    Faraday.new do |f|
      f.options.timeout = TIMEOUT_SECONDS
      f.options.open_timeout = TIMEOUT_SECONDS
      f.response :follow_redirects
      f.adapter Faraday.default_adapter
    end
  end

  class Result
    attr_reader :html, :error

    def self.success(html)
      new(html: html, error: nil)
    end

    def self.failure(error)
      new(html: nil, error: error)
    end

    def initialize(html:, error:)
      @html = html
      @error = error
    end

    def success?
      error.nil?
    end

    def failure?
      !success?
    end
  end
end
```

**Step 5: Run tests to verify they pass**

Run: `cd hub && bin/rails test test/services/url_fetcher_test.rb`
Expected: All tests PASS

**Step 6: Commit**

```bash
git add hub/app/services/url_fetcher.rb hub/test/services/url_fetcher_test.rb hub/test/test_helper.rb hub/Gemfile hub/Gemfile.lock
git commit -m "feat: add UrlFetcher service"
```

---

## Task 5: Create ArticleExtractor service

Extract main article content from HTML, stripping navigation, ads, and boilerplate.

**Files:**
- Create: `hub/app/services/article_extractor.rb`
- Create: `hub/test/services/article_extractor_test.rb`

**Step 1: Write the failing test**

Create `hub/test/services/article_extractor_test.rb`:

```ruby
require "test_helper"

class ArticleExtractorTest < ActiveSupport::TestCase
  test "extracts article content from simple HTML" do
    html = <<~HTML
      <html>
        <head><title>Page Title</title></head>
        <body>
          <nav>Navigation</nav>
          <article>
            <h1>Article Title</h1>
            <p>This is the main content of the article.</p>
            <p>More content here.</p>
          </article>
          <footer>Footer content</footer>
        </body>
      </html>
    HTML

    result = ArticleExtractor.call(html: html)

    assert result.success?
    assert_includes result.text, "Article Title"
    assert_includes result.text, "main content"
    assert_not_includes result.text, "Navigation"
    assert_not_includes result.text, "Footer content"
  end

  test "extracts from main tag if no article" do
    html = <<~HTML
      <html>
        <body>
          <nav>Nav</nav>
          <main>
            <h1>Main Content</h1>
            <p>Body text here.</p>
          </main>
        </body>
      </html>
    HTML

    result = ArticleExtractor.call(html: html)

    assert result.success?
    assert_includes result.text, "Main Content"
    assert_includes result.text, "Body text"
    assert_not_includes result.text, "Nav"
  end

  test "falls back to body if no article or main" do
    html = <<~HTML
      <html>
        <body>
          <div class="content">
            <h1>Page Content</h1>
            <p>Some text.</p>
          </div>
        </body>
      </html>
    HTML

    result = ArticleExtractor.call(html: html)

    assert result.success?
    assert_includes result.text, "Page Content"
  end

  test "removes script tags" do
    html = <<~HTML
      <html>
        <body>
          <article>
            <p>Real content</p>
            <script>alert('bad');</script>
          </article>
        </body>
      </html>
    HTML

    result = ArticleExtractor.call(html: html)

    assert result.success?
    assert_includes result.text, "Real content"
    assert_not_includes result.text, "alert"
  end

  test "removes style tags" do
    html = <<~HTML
      <html>
        <body>
          <article>
            <p>Real content</p>
            <style>.foo { color: red; }</style>
          </article>
        </body>
      </html>
    HTML

    result = ArticleExtractor.call(html: html)

    assert result.success?
    assert_not_includes result.text, "color"
  end

  test "fails when no content found" do
    html = "<html><body></body></html>"

    result = ArticleExtractor.call(html: html)

    assert result.failure?
    assert_equal "Could not extract article content", result.error
  end

  test "returns character count" do
    html = "<article><p>Hello world</p></article>"

    result = ArticleExtractor.call(html: html)

    assert result.success?
    assert result.character_count.positive?
  end
end
```

**Step 2: Run test to verify it fails**

Run: `cd hub && bin/rails test test/services/article_extractor_test.rb`
Expected: FAIL - "uninitialized constant ArticleExtractor"

**Step 3: Create ArticleExtractor service**

Create `hub/app/services/article_extractor.rb`:

```ruby
class ArticleExtractor
  REMOVE_TAGS = %w[script style nav footer header aside form noscript iframe].freeze
  CONTENT_SELECTORS = %w[article main body].freeze
  MIN_CONTENT_LENGTH = 100

  def self.call(html:)
    new(html: html).call
  end

  def initialize(html:)
    @html = html
  end

  def call
    doc = Nokogiri::HTML(html)
    remove_unwanted_elements(doc)
    text = extract_content(doc)

    return Result.failure("Could not extract article content") if text.length < MIN_CONTENT_LENGTH

    Result.success(text)
  end

  private

  attr_reader :html

  def remove_unwanted_elements(doc)
    REMOVE_TAGS.each do |tag|
      doc.css(tag).remove
    end
  end

  def extract_content(doc)
    content_node = find_content_node(doc)
    return "" unless content_node

    content_node.text.gsub(/\s+/, " ").strip
  end

  def find_content_node(doc)
    CONTENT_SELECTORS.each do |selector|
      node = doc.at_css(selector)
      return node if node && node.text.strip.length >= MIN_CONTENT_LENGTH
    end
    nil
  end

  class Result
    attr_reader :text, :error

    def self.success(text)
      new(text: text, error: nil)
    end

    def self.failure(error)
      new(text: nil, error: error)
    end

    def initialize(text:, error:)
      @text = text
      @error = error
    end

    def success?
      error.nil?
    end

    def failure?
      !success?
    end

    def character_count
      text&.length || 0
    end
  end
end
```

**Step 4: Run tests to verify they pass**

Run: `cd hub && bin/rails test test/services/article_extractor_test.rb`
Expected: All tests PASS

**Step 5: Commit**

```bash
git add hub/app/services/article_extractor.rb hub/test/services/article_extractor_test.rb
git commit -m "feat: add ArticleExtractor service"
```

---

## Task 6: Create UrlProcessingPrompt class

Define the LLM prompt for article cleanup, TTS optimization, and metadata extraction.

**Files:**
- Create: `hub/app/services/url_processing_prompt.rb`
- Create: `hub/test/services/url_processing_prompt_test.rb`

**Step 1: Write the failing test**

Create `hub/test/services/url_processing_prompt_test.rb`:

```ruby
require "test_helper"

class UrlProcessingPromptTest < ActiveSupport::TestCase
  test "builds prompt with text content" do
    prompt = UrlProcessingPrompt.build(text: "This is article content.")

    assert_includes prompt, "This is article content."
    assert_includes prompt, "text-to-speech"
    assert_includes prompt, "JSON"
  end

  test "includes all required output fields in instructions" do
    prompt = UrlProcessingPrompt.build(text: "Content")

    assert_includes prompt, "title"
    assert_includes prompt, "author"
    assert_includes prompt, "description"
    assert_includes prompt, "content"
  end
end
```

**Step 2: Run test to verify it fails**

Run: `cd hub && bin/rails test test/services/url_processing_prompt_test.rb`
Expected: FAIL - "uninitialized constant UrlProcessingPrompt"

**Step 3: Create UrlProcessingPrompt class**

Create `hub/app/services/url_processing_prompt.rb`:

```ruby
class UrlProcessingPrompt
  def self.build(text:)
    new(text: text).build
  end

  def initialize(text:)
    @text = text
  end

  def build
    <<~PROMPT
      You are processing a web article for text-to-speech conversion.

      INPUT:
      #{text}

      TASKS:
      1. Extract metadata:
         - title: The article's title
         - author: The author's name (use "Unknown" if not found)
         - description: A single sentence summary

      2. Clean and optimize the content:
         - Remove any leftover navigation, ads, or boilerplate
         - Remove "Subscribe to newsletter" type CTAs
         - Remove any image references or descriptions
         - Expand abbreviations (e.g., "govt" -> "government")
         - Make lists sound natural when read aloud

      OUTPUT FORMAT (JSON only, no markdown):
      {
        "title": "...",
        "author": "...",
        "description": "...",
        "content": "..."
      }
    PROMPT
  end

  private

  attr_reader :text
end
```

**Step 4: Run tests to verify they pass**

Run: `cd hub && bin/rails test test/services/url_processing_prompt_test.rb`
Expected: All tests PASS

**Step 5: Commit**

```bash
git add hub/app/services/url_processing_prompt.rb hub/test/services/url_processing_prompt_test.rb
git commit -m "feat: add UrlProcessingPrompt class"
```

---

## Task 7: Create LlmProcessor service

Orchestrate LLM calls via ruby_llm and record usage costs.

**Files:**
- Create: `hub/app/services/llm_processor.rb`
- Create: `hub/test/services/llm_processor_test.rb`
- Create: `hub/config/initializers/ruby_llm.rb`

**Step 1: Write the failing test**

Create `hub/test/services/llm_processor_test.rb`:

```ruby
require "test_helper"

class LlmProcessorTest < ActiveSupport::TestCase
  setup do
    @episode = episodes(:one)
    @text = "This is some article content about technology trends."
    @user = users(:one)
  end

  test "processes text and returns structured result" do
    mock_response = mock_llm_response(
      content: {
        title: "Technology Trends",
        author: "Unknown",
        description: "An article about technology trends.",
        content: "This is some article content about technology trends."
      }.to_json,
      input_tokens: 100,
      output_tokens: 50,
      model_id: "claude-3-haiku-20240307"
    )

    RubyLLM.stub :chat, mock_chat(mock_response) do
      result = LlmProcessor.call(text: @text, episode: @episode, user: @user)

      assert result.success?
      assert_equal "Technology Trends", result.title
      assert_equal "Unknown", result.author
      assert_includes result.description, "technology"
      assert_includes result.content, "article content"
    end
  end

  test "creates LlmUsage record" do
    mock_response = mock_llm_response(
      content: {
        title: "Test",
        author: "Author",
        description: "Description",
        content: "Content"
      }.to_json,
      input_tokens: 100,
      output_tokens: 50,
      model_id: "claude-3-haiku-20240307"
    )

    RubyLLM.stub :chat, mock_chat(mock_response) do
      assert_difference -> { LlmUsage.count }, 1 do
        LlmProcessor.call(text: @text, episode: @episode, user: @user)
      end

      usage = LlmUsage.last
      assert_equal @episode, usage.episode
      assert_equal "claude-3-haiku-20240307", usage.model_id
      assert_equal "vertex_ai", usage.provider
      assert_equal 100, usage.input_tokens
      assert_equal 50, usage.output_tokens
    end
  end

  test "fails on LLM error" do
    RubyLLM.stub :chat, ->(*) { raise RubyLLM::Error, "API error" } do
      result = LlmProcessor.call(text: @text, episode: @episode, user: @user)

      assert result.failure?
      assert_equal "Failed to process content", result.error
    end
  end

  test "fails on invalid JSON response" do
    mock_response = mock_llm_response(
      content: "not valid json",
      input_tokens: 100,
      output_tokens: 50,
      model_id: "claude-3-haiku-20240307"
    )

    RubyLLM.stub :chat, mock_chat(mock_response) do
      result = LlmProcessor.call(text: @text, episode: @episode, user: @user)

      assert result.failure?
      assert_equal "Failed to process content", result.error
    end
  end

  private

  def mock_llm_response(content:, input_tokens:, output_tokens:, model_id:)
    OpenStruct.new(
      content: content,
      input_tokens: input_tokens,
      output_tokens: output_tokens,
      model_id: model_id
    )
  end

  def mock_chat(response)
    chat = Object.new
    chat.define_singleton_method(:ask) { |_| response }
    ->(*) { chat }
  end
end
```

**Step 2: Run test to verify it fails**

Run: `cd hub && bin/rails test test/services/llm_processor_test.rb`
Expected: FAIL - "uninitialized constant LlmProcessor"

**Step 3: Create RubyLLM initializer**

Create `hub/config/initializers/ruby_llm.rb`:

```ruby
RubyLLM.configure do |config|
  config.vertexai_project_id = ENV["GOOGLE_CLOUD_PROJECT"]
  config.vertexai_location = ENV.fetch("VERTEX_AI_LOCATION", "us-central1")
end
```

**Step 4: Create LlmProcessor service**

Create `hub/app/services/llm_processor.rb`:

```ruby
class LlmProcessor
  MODEL_FREE_PREMIUM = "vertex_ai/claude-3-haiku@20240307"
  MODEL_UNLIMITED = "vertex_ai/claude-3-haiku@20240307"

  def self.call(text:, episode:, user:)
    new(text: text, episode: episode, user: user).call
  end

  def initialize(text:, episode:, user:)
    @text = text
    @episode = episode
    @user = user
  end

  def call
    prompt = UrlProcessingPrompt.build(text: text)
    response = chat.ask(prompt)
    parsed = parse_response(response.content)

    record_usage(response)

    Result.success(
      title: parsed["title"],
      author: parsed["author"],
      description: parsed["description"],
      content: parsed["content"]
    )
  rescue RubyLLM::Error, JSON::ParserError => e
    Rails.logger.error "event=llm_processing_failed episode_id=#{episode.id} error=#{e.message}"
    Result.failure("Failed to process content")
  end

  private

  attr_reader :text, :episode, :user

  def chat
    RubyLLM.chat(model: model_for_user)
  end

  def model_for_user
    user.unlimited? ? MODEL_UNLIMITED : MODEL_FREE_PREMIUM
  end

  def parse_response(content)
    # Strip markdown code blocks if present
    json_content = content.gsub(/```json\n?/, "").gsub(/```\n?/, "").strip
    JSON.parse(json_content)
  end

  def record_usage(response)
    model_info = RubyLLM.models.find(response.model_id)

    unless model_info&.input_price_per_million && model_info&.output_price_per_million
      raise "No pricing info for model: #{response.model_id}"
    end

    input_cost = response.input_tokens * model_info.input_price_per_million / 1_000_000
    output_cost = response.output_tokens * model_info.output_price_per_million / 1_000_000
    total_cost_cents = (input_cost + output_cost) * 100

    LlmUsage.create!(
      episode: episode,
      model_id: response.model_id,
      provider: "vertex_ai",
      input_tokens: response.input_tokens,
      output_tokens: response.output_tokens,
      cost_cents: total_cost_cents
    )
  end

  class Result
    attr_reader :title, :author, :description, :content, :error

    def self.success(title:, author:, description:, content:)
      new(title: title, author: author, description: description, content: content, error: nil)
    end

    def self.failure(error)
      new(title: nil, author: nil, description: nil, content: nil, error: error)
    end

    def initialize(title:, author:, description:, content:, error:)
      @title = title
      @author = author
      @description = description
      @content = content
      @error = error
    end

    def success?
      error.nil?
    end

    def failure?
      !success?
    end
  end
end
```

**Step 5: Run tests to verify they pass**

Run: `cd hub && bin/rails test test/services/llm_processor_test.rb`
Expected: All tests PASS

**Step 6: Commit**

```bash
git add hub/app/services/llm_processor.rb hub/test/services/llm_processor_test.rb hub/config/initializers/ruby_llm.rb
git commit -m "feat: add LlmProcessor service for article cleanup"
```

---

## Task 8: Create ProcessUrlEpisode orchestration service

Orchestrate the full URL-to-TTS pipeline: fetch, extract, validate, LLM process, upload, and enqueue.

**Files:**
- Create: `hub/app/services/process_url_episode.rb`
- Create: `hub/test/services/process_url_episode_test.rb`

**Step 1: Write the failing test**

Create `hub/test/services/process_url_episode_test.rb`:

```ruby
require "test_helper"

class ProcessUrlEpisodeTest < ActiveSupport::TestCase
  setup do
    @user = users(:one)
    @podcast = podcasts(:one)
    @episode = Episode.create!(
      podcast: @podcast,
      user: @user,
      title: "Placeholder",
      author: "Placeholder",
      description: "Placeholder",
      source_type: :url,
      source_url: "https://example.com/article",
      status: :processing
    )
  end

  test "processes URL and updates episode" do
    html = "<article><h1>Real Title</h1><p>Article content here.</p></article>"

    stub_request(:get, "https://example.com/article")
      .to_return(status: 200, body: html)

    mock_llm_result = LlmProcessor::Result.success(
      title: "Real Title",
      author: "John Doe",
      description: "A great article.",
      content: "Article content here."
    )

    LlmProcessor.stub :call, mock_llm_result do
      GcsUploader.stub_any_instance(:upload_staging_file, "staging/test.md") do
        CloudTasksEnqueuer.stub_any_instance(:enqueue_episode_processing, "task-123") do
          ProcessUrlEpisode.call(episode: @episode)
        end
      end
    end

    @episode.reload
    assert_equal "Real Title", @episode.title
    assert_equal "John Doe", @episode.author
    assert_equal "A great article.", @episode.description
  end

  test "marks episode as failed on fetch error" do
    stub_request(:get, "https://example.com/article")
      .to_return(status: 404)

    ProcessUrlEpisode.call(episode: @episode)

    @episode.reload
    assert_equal "failed", @episode.status
    assert_equal "Could not fetch URL", @episode.error_message
  end

  test "marks episode as failed when content too long for tier" do
    long_content = "x" * 20_000
    html = "<article>#{long_content}</article>"

    stub_request(:get, "https://example.com/article")
      .to_return(status: 200, body: html)

    ProcessUrlEpisode.call(episode: @episode)

    @episode.reload
    assert_equal "failed", @episode.status
    assert_equal "This content is too long", @episode.error_message
  end

  test "marks episode as failed on extraction error" do
    html = "<html><body></body></html>"

    stub_request(:get, "https://example.com/article")
      .to_return(status: 200, body: html)

    ProcessUrlEpisode.call(episode: @episode)

    @episode.reload
    assert_equal "failed", @episode.status
    assert_equal "Could not extract article content", @episode.error_message
  end
end
```

**Step 2: Run test to verify it fails**

Run: `cd hub && bin/rails test test/services/process_url_episode_test.rb`
Expected: FAIL - "uninitialized constant ProcessUrlEpisode"

**Step 3: Create ProcessUrlEpisode service**

Create `hub/app/services/process_url_episode.rb`:

```ruby
class ProcessUrlEpisode
  def self.call(episode:)
    new(episode: episode).call
  end

  def initialize(episode:)
    @episode = episode
    @user = episode.user
  end

  def call
    fetch_url
    extract_content
    check_character_limit
    process_with_llm
    update_episode_metadata
    upload_and_enqueue

    Rails.logger.info "event=url_episode_processed episode_id=#{episode.id}"
  rescue ProcessingError => e
    fail_episode(e.message)
  rescue StandardError => e
    Rails.logger.error "event=url_episode_failed episode_id=#{episode.id} error=#{e.message}"
    fail_episode(e.message)
  end

  private

  attr_reader :episode, :user

  def fetch_url
    @fetch_result = UrlFetcher.call(url: episode.source_url)
    raise ProcessingError, @fetch_result.error if @fetch_result.failure?
  end

  def extract_content
    @extract_result = ArticleExtractor.call(html: @fetch_result.html)
    raise ProcessingError, @extract_result.error if @extract_result.failure?
  end

  def check_character_limit
    max_chars = max_characters_for(user)
    return unless max_chars && @extract_result.character_count > max_chars

    raise ProcessingError, "This content is too long"
  end

  def process_with_llm
    @llm_result = LlmProcessor.call(text: @extract_result.text, episode: episode, user: user)
    raise ProcessingError, @llm_result.error if @llm_result.failure?
  end

  def update_episode_metadata
    episode.update!(
      title: @llm_result.title,
      author: @llm_result.author,
      description: @llm_result.description
    )
  end

  def upload_and_enqueue
    staging_path = upload_to_staging(@llm_result.content)
    enqueue_processing(staging_path)
  end

  def fail_episode(error_message)
    episode.update!(status: :failed, error_message: error_message)
    Rails.logger.info "event=url_episode_failed episode_id=#{episode.id} error=#{error_message}"
  end

  def max_characters_for(user)
    case user.tier
    when "free" then EpisodeSubmissionValidator::MAX_CHARACTERS_FREE
    when "premium" then EpisodeSubmissionValidator::MAX_CHARACTERS_PREMIUM
    when "unlimited" then nil
    end
  end

  def upload_to_staging(content)
    filename = "#{episode.id}-#{Time.now.to_i}.md"
    gcs_uploader.upload_staging_file(content: content, filename: filename)
  end

  def enqueue_processing(staging_path)
    CloudTasksEnqueuer.new.enqueue_episode_processing(
      episode_id: episode.id,
      podcast_id: episode.podcast.podcast_id,
      staging_path: staging_path,
      metadata: {
        title: episode.title,
        author: episode.author,
        description: episode.description
      },
      voice_name: user.voice_name
    )
  end

  def gcs_uploader
    @gcs_uploader ||= GcsUploader.new(
      ENV.fetch("GOOGLE_CLOUD_BUCKET"),
      podcast_id: episode.podcast.podcast_id
    )
  end

  class ProcessingError < StandardError; end
end
```

**Step 4: Run tests to verify they pass**

Run: `cd hub && bin/rails test test/services/process_url_episode_test.rb`
Expected: All tests PASS

**Step 5: Commit**

```bash
git add hub/app/services/process_url_episode.rb hub/test/services/process_url_episode_test.rb
git commit -m "feat: add ProcessUrlEpisode orchestration service"
```

---

## Task 9: Create ProcessUrlEpisodeJob

Thin background job that delegates to the ProcessUrlEpisode service.

**Files:**
- Create: `hub/app/jobs/process_url_episode_job.rb`
- Create: `hub/test/jobs/process_url_episode_job_test.rb`

**Step 1: Write the failing test**

Create `hub/test/jobs/process_url_episode_job_test.rb`:

```ruby
require "test_helper"

class ProcessUrlEpisodeJobTest < ActiveSupport::TestCase
  setup do
    @user = users(:one)
    @podcast = podcasts(:one)
    @episode = Episode.create!(
      podcast: @podcast,
      user: @user,
      title: "Placeholder",
      author: "Placeholder",
      description: "Placeholder",
      source_type: :url,
      source_url: "https://example.com/article",
      status: :processing
    )
  end

  test "delegates to ProcessUrlEpisode service" do
    called_with = nil
    ProcessUrlEpisode.stub :call, ->(episode:) { called_with = episode } do
      ProcessUrlEpisodeJob.perform_now(@episode.id)
    end

    assert_equal @episode, called_with
  end

  test "finds episode by id" do
    ProcessUrlEpisode.stub :call, ->(**) {} do
      ProcessUrlEpisodeJob.perform_now(@episode.id)
    end
    # No error means episode was found
  end
end
```

**Step 2: Run test to verify it fails**

Run: `cd hub && bin/rails test test/jobs/process_url_episode_job_test.rb`
Expected: FAIL - "uninitialized constant ProcessUrlEpisodeJob"

**Step 3: Create ProcessUrlEpisodeJob**

Create `hub/app/jobs/process_url_episode_job.rb`:

```ruby
class ProcessUrlEpisodeJob < ApplicationJob
  queue_as :default

  def perform(episode_id)
    episode = Episode.find(episode_id)
    ProcessUrlEpisode.call(episode: episode)
  end
end
```

**Step 4: Run tests to verify they pass**

Run: `cd hub && bin/rails test test/jobs/process_url_episode_job_test.rb`
Expected: All tests PASS

**Step 5: Commit**

```bash
git add hub/app/jobs/process_url_episode_job.rb hub/test/jobs/process_url_episode_job_test.rb
git commit -m "feat: add ProcessUrlEpisodeJob"
```

---

## Task 10: Create CreateUrlEpisode service

Handle URL episode creation with validation and job enqueueing.

**Files:**
- Create: `hub/app/services/create_url_episode.rb`
- Create: `hub/test/services/create_url_episode_test.rb`

**Step 1: Write the failing test**

Create `hub/test/services/create_url_episode_test.rb`:

```ruby
require "test_helper"

class CreateUrlEpisodeTest < ActiveSupport::TestCase
  setup do
    @user = users(:one)
    @podcast = podcasts(:one)
  end

  test "creates episode with processing status" do
    result = nil
    assert_enqueued_with(job: ProcessUrlEpisodeJob) do
      result = CreateUrlEpisode.call(
        podcast: @podcast,
        user: @user,
        url: "https://example.com/article"
      )
    end

    assert result.success?
    assert result.episode.persisted?
    assert_equal "processing", result.episode.status
    assert_equal "url", result.episode.source_type
    assert_equal "https://example.com/article", result.episode.source_url
  end

  test "creates episode with placeholder metadata" do
    result = CreateUrlEpisode.call(
      podcast: @podcast,
      user: @user,
      url: "https://example.com/article"
    )

    assert_equal "Processing...", result.episode.title
    assert_equal "Processing...", result.episode.author
    assert_equal "Processing article from URL...", result.episode.description
  end

  test "fails on invalid URL format" do
    result = CreateUrlEpisode.call(
      podcast: @podcast,
      user: @user,
      url: "not-a-valid-url"
    )

    assert result.failure?
    assert_equal "Invalid URL", result.error
    assert_nil result.episode
  end

  test "fails on empty URL" do
    result = CreateUrlEpisode.call(
      podcast: @podcast,
      user: @user,
      url: ""
    )

    assert result.failure?
    assert_equal "Invalid URL", result.error
  end

  test "enqueues ProcessUrlEpisodeJob" do
    assert_enqueued_with(job: ProcessUrlEpisodeJob) do
      CreateUrlEpisode.call(
        podcast: @podcast,
        user: @user,
        url: "https://example.com/article"
      )
    end
  end
end
```

**Step 2: Run test to verify it fails**

Run: `cd hub && bin/rails test test/services/create_url_episode_test.rb`
Expected: FAIL - "uninitialized constant CreateUrlEpisode"

**Step 3: Create CreateUrlEpisode service**

Create `hub/app/services/create_url_episode.rb`:

```ruby
class CreateUrlEpisode
  def self.call(podcast:, user:, url:)
    new(podcast: podcast, user: user, url: url).call
  end

  def initialize(podcast:, user:, url:)
    @podcast = podcast
    @user = user
    @url = url
  end

  def call
    return Result.failure("Invalid URL") unless valid_url?

    episode = create_episode
    ProcessUrlEpisodeJob.perform_later(episode.id)

    Rails.logger.info "event=url_episode_created episode_id=#{episode.id} url=#{url}"

    Result.success(episode)
  end

  private

  attr_reader :podcast, :user, :url

  def valid_url?
    return false if url.blank?

    uri = URI.parse(url)
    uri.is_a?(URI::HTTP) || uri.is_a?(URI::HTTPS)
  rescue URI::InvalidURIError
    false
  end

  def create_episode
    podcast.episodes.create!(
      user: user,
      title: "Processing...",
      author: "Processing...",
      description: "Processing article from URL...",
      source_type: :url,
      source_url: url,
      status: :processing
    )
  end

  class Result
    attr_reader :episode, :error

    def self.success(episode)
      new(episode: episode, error: nil)
    end

    def self.failure(error)
      new(episode: nil, error: error)
    end

    def initialize(episode:, error:)
      @episode = episode
      @error = error
    end

    def success?
      error.nil?
    end

    def failure?
      !success?
    end
  end
end
```

**Step 4: Run tests to verify they pass**

Run: `cd hub && bin/rails test test/services/create_url_episode_test.rb`
Expected: All tests PASS

**Step 5: Commit**

```bash
git add hub/app/services/create_url_episode.rb hub/test/services/create_url_episode_test.rb
git commit -m "feat: add CreateUrlEpisode service"
```

---

## Task 11: Update controller to handle URL submissions

Add URL detection to the existing create action, branching by params.

**Files:**
- Modify: `hub/app/controllers/episodes_controller.rb`
- Modify: `hub/test/controllers/episodes_controller_test.rb` (if exists, or create)

**Step 1: Write the failing test**

Create or modify `hub/test/controllers/episodes_controller_test.rb`:

```ruby
require "test_helper"

class EpisodesControllerTest < ActionDispatch::IntegrationTest
  setup do
    @user = users(:one)
    @podcast = podcasts(:one)
    sign_in(@user)
  end

  test "create with url param creates URL episode and redirects" do
    assert_enqueued_with(job: ProcessUrlEpisodeJob) do
      post episodes_path, params: { url: "https://example.com/article" }
    end

    assert_redirected_to episodes_path
    follow_redirect!
    assert_match /Processing/, response.body
  end

  test "create with url param fails with invalid URL" do
    post episodes_path, params: { url: "not-a-url" }

    assert_response :unprocessable_entity
  end

  test "create with url param records episode usage" do
    assert_difference -> { EpisodeUsage.sum(:episode_count) }, 1 do
      post episodes_path, params: { url: "https://example.com/article" }
    end
  end

  private

  def sign_in(user)
    session = user.sessions.create!
    post session_path, params: { token: session.id }
  end
end
```

Note: You may need to adjust the sign_in helper based on your existing authentication test setup.

**Step 2: Run test to verify it fails**

Run: `cd hub && bin/rails test test/controllers/episodes_controller_test.rb`
Expected: FAIL - URL param not handled

**Step 3: Update controller to branch by params**

Modify `hub/app/controllers/episodes_controller.rb`, replace the `create` action:

```ruby
def create
  if params[:url].present?
    create_from_url
  else
    create_from_markdown
  end
end

private

def create_from_url
  result = CreateUrlEpisode.call(
    podcast: @podcast,
    user: Current.user,
    url: params[:url]
  )

  if result.success?
    RecordEpisodeUsage.call(user: Current.user)
    redirect_to episodes_path, notice: "Processing article from URL..."
  else
    flash.now[:alert] = result.error
    @episode = @podcast.episodes.build
    render :new, status: :unprocessable_entity
  end
end

def create_from_markdown
  validation = EpisodeSubmissionValidator.call(user: Current.user)

  result = EpisodeSubmissionService.call(
    podcast: @podcast,
    user: Current.user,
    params: episode_params,
    uploaded_file: params[:episode][:content],
    max_characters: validation.max_characters,
    voice_name: Current.user.voice_name
  )

  if result.success?
    RecordEpisodeUsage.call(user: Current.user)
    redirect_to episodes_path, notice: "Episode created! Processing..."
  else
    @episode = result.episode
    flash.now[:alert] = @episode.error_message if @episode.error_message

    if @episode.errors[:content].any?
      flash.now[:alert] = @episode.errors[:content].first
    end

    render :new, status: :unprocessable_entity
  end
end
```

**Step 4: Run tests to verify they pass**

Run: `cd hub && bin/rails test test/controllers/episodes_controller_test.rb`
Expected: All tests PASS

**Step 5: Commit**

```bash
git add hub/app/controllers/episodes_controller.rb hub/test/controllers/episodes_controller_test.rb
git commit -m "feat: handle URL submissions in create action"
```

---

## Task 12: Update view with segmented control UI

Add the tabbed interface for switching between markdown upload and URL submission.

**Files:**
- Modify: `hub/app/views/episodes/new.html.erb`
- Create: `hub/app/javascript/controllers/tab_switch_controller.js`

**Step 1: Create Stimulus controller for tab switching**

Create `hub/app/javascript/controllers/tab_switch_controller.js`:

```javascript
import { Controller } from "@hotwired/stimulus"

export default class extends Controller {
  static targets = ["tab", "panel"]

  switch(event) {
    const selectedTab = event.currentTarget.dataset.tab

    // Update tab styles
    this.tabTargets.forEach(tab => {
      if (tab.dataset.tab === selectedTab) {
        tab.classList.add("bg-[var(--color-surface0)]", "text-[var(--color-text)]")
        tab.classList.remove("text-[var(--color-subtext)]")
      } else {
        tab.classList.remove("bg-[var(--color-surface0)]", "text-[var(--color-text)]")
        tab.classList.add("text-[var(--color-subtext)]")
      }
    })

    // Show/hide panels
    this.panelTargets.forEach(panel => {
      if (panel.dataset.tab === selectedTab) {
        panel.classList.remove("hidden")
      } else {
        panel.classList.add("hidden")
      }
    })
  }
}
```

**Step 2: Update the new episode view**

Replace `hub/app/views/episodes/new.html.erb`:

```erb
<div class="max-w-2xl mx-auto">
  <h1 class="text-2xl font-semibold mb-8">Create New Episode</h1>

  <%= render "shared/card", padding: "p-4 sm:p-8" do %>
    <div data-controller="tab-switch">
      <!-- Segmented Control -->
      <div class="flex bg-[var(--color-base)] rounded-lg p-1 mb-6">
        <button
          type="button"
          data-tab-switch-target="tab"
          data-tab="markdown"
          data-action="click->tab-switch#switch"
          class="flex-1 py-2 px-4 rounded-md text-sm font-medium transition-colors bg-[var(--color-surface0)] text-[var(--color-text)]"
        >
          Paste Markdown
        </button>
        <button
          type="button"
          data-tab-switch-target="tab"
          data-tab="url"
          data-action="click->tab-switch#switch"
          class="flex-1 py-2 px-4 rounded-md text-sm font-medium transition-colors text-[var(--color-subtext)]"
        >
          From URL
        </button>
      </div>

      <!-- Markdown Form Panel -->
      <div data-tab-switch-target="panel" data-tab="markdown">
        <%= form_with model: @episode, url: episodes_path, local: true, multipart: true, class: "space-y-6" do |f| %>
          <% if @episode.errors.any? %>
            <div class="border border-[var(--color-red)] rounded-lg p-4 bg-[var(--color-red)]/10">
              <p class="text-[var(--color-red)] font-medium mb-2">Please fix the following errors:</p>
              <ul class="list-disc list-inside text-sm text-[var(--color-red)]">
                <% @episode.errors.full_messages.each do |message| %>
                  <li><%= message %></li>
                <% end %>
              </ul>
            </div>
          <% end %>

          <div>
            <%= f.label :title, class: label_classes %>
            <%= f.text_field :title,
                class: input_classes,
                placeholder: "My Awesome Episode" %>
          </div>

          <div>
            <%= f.label :author, class: label_classes %>
            <%= f.text_field :author,
                class: input_classes,
                placeholder: "Your Name" %>
          </div>

          <div>
            <%= f.label :description, class: label_classes %>
            <%= f.text_area :description,
                rows: 3,
                class: input_classes,
                placeholder: "A brief description of this episode..." %>
          </div>

          <div data-controller="file-upload">
            <%= f.label :content, "Markdown Content", class: label_classes %>
            <div
              data-file-upload-target="dropzone"
              data-action="click->file-upload#triggerInput dragover->file-upload#handleDragOver dragleave->file-upload#handleDragLeave drop->file-upload#handleDrop"
              class="border-2 border-dashed border-[var(--color-overlay0)] rounded-lg p-4 sm:p-8 text-center cursor-pointer hover:border-[var(--color-primary)] transition-colors"
            >
              <%= f.file_field :content,
                  accept: ".md,.markdown,.txt",
                  required: true,
                  data: { file_upload_target: "input", action: "change->file-upload#updateFilename" },
                  class: "hidden" %>
              <p class="text-[var(--color-subtext)] mb-2">Click to upload or drag and drop<br>(.md or .txt)</p>
              <p data-file-upload-target="filename" class="hidden text-sm font-medium text-[var(--color-primary)]"></p>
            </div>
          </div>

          <div class="flex flex-col sm:flex-row sm:items-center gap-4 pt-4">
            <%= f.submit "Create Episode", class: button_classes(type: :primary, full_width: false) + " sm:w-auto w-full" %>
            <%= link_to "Cancel", episodes_path, class: button_classes(type: :text) + " text-center" %>
          </div>
        <% end %>
      </div>

      <!-- URL Form Panel -->
      <div data-tab-switch-target="panel" data-tab="url" class="hidden">
        <%= form_with url: episodes_path, local: true, class: "space-y-6" do |f| %>
          <div>
            <%= f.label :url, "Article URL", class: label_classes %>
            <%= f.url_field :url,
                class: input_classes,
                placeholder: "https://example.com/article",
                required: true %>
            <p class="mt-2 text-sm text-[var(--color-subtext)]">
              We'll extract the article content, title, and author automatically.
            </p>
          </div>

          <div class="flex flex-col sm:flex-row sm:items-center gap-4 pt-4">
            <%= f.submit "Create Episode", class: button_classes(type: :primary, full_width: false) + " sm:w-auto w-full" %>
            <%= link_to "Cancel", episodes_path, class: button_classes(type: :text) + " text-center" %>
          </div>
        <% end %>
      </div>
    </div>
  <% end %>
</div>
```

**Step 3: Register the Stimulus controller**

Verify the controller is auto-loaded. If using importmap, it should be automatic. If not, add to `hub/app/javascript/controllers/index.js`:

```javascript
import TabSwitchController from "./tab_switch_controller"
application.register("tab-switch", TabSwitchController)
```

**Step 4: Test manually in browser**

Run: `cd hub && bin/rails server`
Visit: `http://localhost:3000/episodes/new`
Expected: See segmented control, clicking tabs switches forms

**Step 5: Commit**

```bash
git add hub/app/views/episodes/new.html.erb hub/app/javascript/controllers/tab_switch_controller.js
git commit -m "feat: add segmented control UI for markdown/URL episode creation"
```

---

## Task 13: Update episode card to show source URL

Display the source URL on episode cards for URL-sourced episodes.

**Files:**
- Modify: `hub/app/views/episodes/_episode_card.html.erb`

**Step 1: Read current episode card**

Review current implementation at `hub/app/views/episodes/_episode_card.html.erb`

**Step 2: Update episode card to show source URL**

Add after the title or in an appropriate location in the card:

```erb
<% if episode.url? && episode.source_url.present? %>
  <p class="text-xs text-[var(--color-subtext)] truncate mt-1">
    <%= link_to episode.source_url, episode.source_url, target: "_blank", class: "hover:underline" %>
  </p>
<% end %>
```

**Step 3: Test manually**

Create a URL-based episode and verify the URL displays in the card.

**Step 4: Commit**

```bash
git add hub/app/views/episodes/_episode_card.html.erb
git commit -m "feat: show source URL in episode card"
```

---

## Task 14: Add environment variables documentation

Document the new Vertex AI environment variable in .env.example.

**Files:**
- Modify: `hub/.env.example`

**Step 1: Update .env.example**

Add the following variables:

```bash
# Vertex AI (for LLM processing)
VERTEX_AI_LOCATION=us-central1
```

Note: `GOOGLE_CLOUD_PROJECT` should already exist for Cloud Tasks/Storage.

**Step 2: Commit**

```bash
git add hub/.env.example
git commit -m "docs: add Vertex AI env vars to .env.example"
```

---

## Task 15: Run full test suite

Verify all tests pass and code meets linting standards before deployment.

**Step 1: Run all tests**

Run: `cd hub && bin/rails test`
Expected: All tests PASS

**Step 2: Run linter**

Run: `cd hub && bin/rubocop`
Expected: No offenses (or fix any that appear)

**Step 3: Final commit if any fixes**

```bash
git add -A
git commit -m "fix: address test/linter issues"
```

---

## Summary

This plan implements:

1. **Database changes:** `llm_usages` table, `source_url`/`source_type` on episodes
2. **Services:** `UrlFetcher`, `ArticleExtractor`, `LlmProcessor`, `CreateUrlEpisode`
3. **Background job:** `ProcessUrlEpisodeJob` for async processing
4. **Controller:** `create_from_url` action
5. **UI:** Segmented control for markdown/URL input modes
6. **Cost tracking:** Per-episode LLM usage recording

The Generator service remains unchanged - all URL processing happens in Hub before content reaches the existing TTS pipeline.
